*fold.txt*      For Vim version 7.4.  最後修改: 2010年5月


		  VIM REFERENCE MANUAL    by Bram Moolenaar
		      譯者: Zimin<cranecai@users.sf.net>，tocer


摺疊						*Folding* *folding* *folds*

你可以在用戶手冊的第 28 章找到有關摺疊的序論。|usr_28.txt|

1. 摺疊方法		|fold-methods|
2. 摺疊命令		|fold-commands|
3. 摺疊選項		|fold-options|
4. 摺疊行爲		|fold-behavior|

{Vi 沒有摺疊}
{僅當編譯時加入 |+folding| 特性纔有效}

==============================================================================
1. 摺疊方法					*fold-methods*

可用選項 'foldmethod' 來設定摺疊方法。

設置選項 'foldmethod' 爲非 "manual" 的其它值時，所有的摺疊都會被刪除並且創建新
的。如果設置成 "manual"，將不去除已有的摺疊。可以利用這一點來先自動定義摺疊，
然後手工調整。

有 6 種方法來選定摺疊:
	manual		手工定義摺疊
	indent		更多的縮進表示更高級別的摺疊
	expr		用表達式來定義摺疊
	syntax		用語法高亮來定義摺疊
	diff		對沒有更改的文本進行摺疊
	marker		對文中的標誌摺疊


手 工						*fold-manual*

使用命令來手工定義要摺疊的範圍。分析文本並發現摺疊的腳本也可用這種方法。

摺疊的級別僅由嵌套次數來定義。要對一定行數的摺疊增加級別，可以對相同的行反覆定
義摺疊。

當你退出文件編輯時，手工摺疊會被遺棄。要保存摺疊，使用 |:mkview| 命令。之後要
恢復可以使用 |:loadview|。


縮 進						*fold-indent*

由縮進行自動定義摺疊。

摺疊級別由行的縮進除以 'shiftwidth' (向下取整) 計算而得。連續的，有同樣或更高
的摺疊級別的行，形成一個摺疊。在其中，有更高摺疊級別的行形成嵌套的摺疊。

嵌套的級別數受 'foldnestmax' 選項限制。

某些行會被忽略並得到上一行或下一行的摺疊級別 (取較小值)。符合條件的這樣的行要
麼是空行，要麼以 'foldignore' 選項裏包含的字符開始。在查找 'foldignore' 裏包含
的字符時，空白字符會被忽略。對於 C，該選項使用 "#" 來略過要預處理的那些行。

當你想用另一種方式來略過行時，使用 'expr' 方法。在 'foldexpr' 中 |indent()| 函
數被用來取得一行的縮進。


表 達 式						*fold-expr*

就象用 "indent" 方式一樣，表達式方式的摺疊也是由摺疊級別自動定義的。對每行，通
過計算選項 'foldexpr' 的值來並得到它的摺疊級別。如:
對所有以製表符開始的連續的幾行，創建摺疊: >
	:set foldexpr=getline(v:lnum)[0]==\"\\t\"
調用一函數來計算摺疊級別:   >
	:set foldexpr=MyFoldLevel(v:lnum)
用空白行分開的段落構成摺疊:   >
	:set foldexpr=getline(v:lnum)=~'^\\s*$'&&getline(v:lnum+1)=~'\\S'?'<1':1
同上:   >
	:set foldexpr=getline(v:lnum-1)=~'^\\s*$'&&getline(v:lnum)=~'\\S'?'>1':1
備註: ":set" 要特殊處理的字符必須用反斜槓轉義。(空格，反斜槓，雙引號等等，參考
|option-backslash|)

這些是表達式的計算條件:
- 當前緩衝區和窗口值依所在行而定
- 變量 "v:lnum" 被定爲該行行號
- 計算結果將用以下方式解釋:
  值			代表 ~
  0			這行不摺疊
  1, 2, ..		這行的摺疊級別 1，2 等
  -1			摺疊級別沒有定義，使用這行之前或之後一行的級別值，取其
  			中較小的一個。
  "="			使用上一行的摺疊級別。
  "a1", "a2", ..	上一行的摺疊級別加 1，2，..
  "s1", "s2", ..	上一行的摺疊級別減 1，2，..
  "<1", "<2", ..	此摺疊級別在本行結束
  ">1", ">2", ..	此摺疊級別在本行開始

不需要用 ">1" ("<1") 標誌摺疊的開始 (結束)。當這行摺疊級別高於 (低於) 上一行的
級別時，摺疊將開始 (結束)。

表達式必須沒有副作用。在緩衝區裏的文字，光標位置，查找模式，選項等等，不能被改
動。如果你非常小心，改動並恢復這些設置還是可以的。

表達式中有錯誤或者計算結果不能識別時，Vim 不會產生錯誤消息，而是將摺疊級別設爲
0。所以當需要調試時，可將 'debug' 選項設爲 "msg"，錯誤消息就可以被見到了。

備註: 由於每一行關於表達式的值都要被計算，這一摺疊方式可能會很慢！

最好避免使用 "=" ， "a" 和 "s" 作爲返回值，因爲 Vim 不得不經常向後回溯以得到折
疊級別。這會降低執行速度。

|foldlevel()| 計算相對於上一摺疊級別的摺疊級別。但要注意，如果該級別未知，
foidlevel() 返回 -1。它返回的級別對應於該行開始的位置，儘管摺疊本身可能在該行
結束。

摺疊可能會沒有及時更新。用 |zx| 或者 |zX| 可以強制摺疊更新。


語 法						*fold-syntax*

由帶有 "fold" 參數的語法項來定義摺疊。|:syn-fold|

摺疊級別由嵌套的摺疊層數來定義。嵌套數由 'foldnestmax' 限定。

要小心指定合適的語法同步方式。如果這裏有問題，摺疊和顯示高亮可能會不一致。尤其
在使用可能跨越多行的模式時更要小心。如果有疑問，不妨嘗試如下的強制同步: >
	:syn sync fromstart
<

比 較						*fold-diff*

對沒有改動的文本或靠近改動的文本自動定義摺疊。

這個方法僅適用於當前窗口設定 'diff' 選項來顯示不同之處時纔有效。不然，整個緩衝
區就是一個大的摺疊。

選項 'diffopt' 可以指定上下文。即摺疊和不被摺疊包括的改變之間相距的行數。比
如，設定上下文爲 8: >
	:set diffopt=filler,context:8
默認值是 6。

當設定了 'scrollbind' 選項時，Vim 會試圖在其它比較窗口中打開相同的摺疊，這樣這
些窗口就會顯示同一處文本。


標 志						*fold-marker*

在文本中可以加入標誌來指明摺疊開始和結束的地方。這可以讓你精確的定義摺疊。這也
讓你可以放心地刪除和複製摺疊而不用擔心錯誤包括了某些行。選項 'foldtext' 通常設
置爲使摺疊行顯示摺疊標誌之前的文本。這樣做可以爲摺疊命名。

標誌可以包含級別數，也可以使用匹配對。包含級別數較簡單，你無須添加結束標誌，並
可以避免標誌不配對的問題。如: >
	/* global variables {{{1 */
	int varA, varB;

	/* functions {{{1 */
	/* funcA() {{{2 */
	void funcA() {}

	/* funcB() {{{2 */
	void funcB() {}

摺疊開始於 "{{{" 標誌。接下去的數字決定了摺疊級別。產生的效果依當前摺疊級別和
該摺疊標誌給定的級別的大小關係而定:
1. 如果遇到級別相同的標誌，上一個摺疊結束，另一個有同樣級別的摺疊開始。
2. 如果遇到級別更高的標誌，開始一個嵌套的摺疊。
3. 如果遇到級別更低的標誌，所有大於或等於當前級別的摺疊結束，且指定級別的摺疊
   開始。

數字指定了摺疊級別。不能使用 0 (忽略級別爲 0 的標誌)。你可以使用 "}}}" 帶上一
個數字來表示這個級別的摺疊結束。此行以下的摺疊級別將比當前級別小一。備註: Vim
不會回溯匹配的標誌 (這將耗費太多的時間)。如: >

	{{{1
	fold level here is 1
	{{{3
	fold level here is 3
	}}}3
	fold level here is 2

你也可以用一對匹配標誌 "{{{" 和 "}}}" 來定義摺疊。每個 "{{{" 使摺疊級別加 1，
"}}}" 使摺疊級別減 1。注意一定要使標誌匹配！如: >

	{{{
	fold level here is 1
	{{{
	fold level here is 2
	}}}
	fold level here is 1

帶數字的標誌和沒有帶數字的標誌可以混合使用。對於一個大摺疊我們可以使用帶數字的
標誌，在函數的內部我們可以使用不帶數字的。如對文件中的 "結構定義"，"局部變量"
和 "函數原型" 各個部分，使用級別 1 的摺疊。對定義和函數體使用級別 2 的標誌。而
在函數內部可以使用不帶數字的標誌。當你在一函數中作更改以分割摺疊時，你無須記着
標志在哪裏。

選項 'foldmarker' 可設定所用的標誌。建議保留默認值 "{{{,}}}"。這樣在 Vim 用戶
間交換文件時就不會出問題。有時爲了要編輯的文件必須改變該選項 (如，文件包含了來
自另一個編輯器的摺疊標誌，或對於當前文件的語法而言，摺疊標誌會產生歧義等)。

							*fold-create-marker*
"zf" 可通過標誌來創建一個摺疊。 Vim 將爲你插入開始和結束標誌。這些標誌由
'foldmarker' 指定。標誌會被添加在行末。如果 'commentstring' 不爲空，使用之。
以下情況下可能無法正常工作:
- 此行已有一個帶級別的標誌了。Vim 無法判斷該如何做。
- 在附近的摺疊裏使用了帶級別的標誌，使添加無法進行。
- 這行包含在一註釋中，且 'commentstring' 不爲空，且嵌套的註釋是非法的。如，在
  C 的註釋中加入 /* {{{ */ ，這將使現有的註釋中斷。你可以在註釋之前或之後添加
  標誌，或手工添加。
總的來說，當你已有帶級別的標誌時，再讓 Vim 爲你創建標誌不是個好主意。

							*fold-delete-marker*
"zd" 可用來刪除一個用標誌定義的摺疊。 Vim 將爲你刪除標誌。Vim 將在摺疊的開始和
結束處根據 'foldmarker' 查找開始和結束標誌。如果標誌周圍文字和 'commentstring'
匹配，這些文字也會被刪除。
但在以下情況下無法正確執行:
- 當一行包含有多於一個的標誌且其中一個指定了級別。Vim 不考慮結果是不是真能刪除
  摺疊，而僅刪除第一個標誌。
- 當這個標誌帶有級別且同時被用來開始或結束幾個摺疊時。

==============================================================================
2. 摺疊命令					*fold-commands* *E490*

所有的摺疊命令用 "z" 開頭。提示: 如果你從側面看 "z" 象一張疊起來的紙。


創 建 和 刪 除 折 疊 ~
							*zf* *E350*
zf{motion}  或
{Visual}zf	創建摺疊操作符。
		僅當 'foldmethod' 設爲 "manual" 或 "marker" 時有效。
		用 "manual" 方式，新建的摺疊會被關閉。同時 'foldenable' 會被設
		定。
		參考 |fold-create-marker|。

							*zF*
zF		對 [count] 行創建摺疊。其餘同 "zf" 。

:{range}fo[ld]						*:fold* *:fo*
		對 {range} 內的行創建摺疊。其餘同 "zf" 。

							*zd* *E351*
zd		刪除 (delete) 在光標下的摺疊。當光標在被摺疊的行上，該摺疊被刪
		除。嵌套的摺疊上移一級。在可視模式下所選區域 (部分) 涵蓋的摺疊
		都被刪除。注意: 這種一次刪除多個摺疊的簡單方法不可撤銷。
		僅當 'foldmethod' 設爲 "manual" 或 "marker" 時有效。
		參考 |fold-delete-marker|。

							*zD*
zD		循環刪除 (Delete) 光標下的摺疊。在可視模式下所選區域 (部分) 涵
		蓋的摺疊和嵌套的摺疊都被刪除。
		僅當 'foldmethod' 設爲 "manual" 或 "marker" 時有效。
		參考 |fold-delete-marker|。

							*zE* *E352*
zE		除去 (Eliminate) 窗口裏所有的摺疊。
		僅當 'foldmethod' 設爲 "manual" 或 "marker" 時有效。
		參考 |fold-delete-marker|。


打 開 和 關 閉 折 疊 ~

一個小於 'foldminlines' 的摺疊的顯示就象它被打開時一樣。所以，以下的命令對於小
摺疊所起的作用與描述不同。

							*zo*
zo		打開 (open) 在光標下的摺疊。當給定計數時，相應深度的摺疊被打
		開。在可視模式下，所選區域的所有行的摺疊被打開一級。

							*zO*
zO		循環打開 (Open) 光標下的摺疊。不在光標下的摺疊不改變。
		在可視模式下，打開所有的在選中區域裏的摺疊，包括被部分選中的。

							*zc*
zc		關閉 (close) 在光標下的摺疊。當給定計數時，相應深度的摺疊被關
		閉。在可視模式下，所選區域裏的所有行的摺疊被關閉一級。
		'foldenable' 被設定。

							*zC*
zC		循環關閉 (Close) 在光標下的所有摺疊。不在光標下的摺疊不改變。
		在可視模式下，關閉所有的在選中區域裏的摺疊，包括被部分選中的。
		'foldenable' 被設定。

							*za*
za		當光標位於一關閉的摺疊上時，打開之。當摺疊嵌套時，你可能需要用
		"za" 數次。當給定計數時，打開相應數量的被關閉的摺疊。
		當光標位於一打開的摺疊上時，關閉之且設定 'foldenable' 。這僅關
		閉一級摺疊，因爲再次使用 "za" 將再次打開摺疊。當給定計數時，關
		閉相應數量的摺疊 (這不同於重複 "za" 許多次)。

							*zA*
zA		當處在一關閉的摺疊上時，循環地打開摺疊。
		當處在一打開的摺疊上時，循環地關閉摺疊且設定 'foldenable'。

							*zv*
zv		查看 (view) 光標所在的行: 僅打開足夠的摺疊使光標所在的行不被折
		疊。

							*zx*
zx		更新摺疊: 撤消被手工打開和關閉的摺疊: 再次應用 'foldlevel'。
		然後使用 "zv" : 查看光標所在行。
		同時強制重新計算摺疊。使用 "foldexpr" 並且緩衝區發生改變但摺疊
		不能正確地更新時，這會有用。

							*zX*
zX		手工恢覆被打開和關閉的摺疊: 再次應用 'foldlevel'。
		也同時強制重新計算摺疊，同 |zx|。

							*zm*
zm		折起更多 (more): 'foldlevel' 減 1。如果 'foldlevel' 已經爲 0，
		則不會被減小。
		'foldenable' 被設定。

							*zM*
zM		關閉所有摺疊: 'foldlevel' 設爲 0。
		'foldenable' 被設定。

							*zr*
zr		減少 (reduce) 摺疊: 'foldlevel' 加 1。

							*zR*
zR		打開所有的摺疊。'foldlevel' 設爲最高級別。

							*:foldo* *:foldopen*
:{range}foldo[pen][!]
		在 {range} 內打開摺疊。當加上 [!] 時，所有的摺疊都被打開。對查
		看在 {range} 內的所有文本很有用。沒有 [!] 時，打開一級摺疊。

							*:foldc* *:foldclose*
:{range}foldc[lose][!]
		在 {range} 內關閉摺疊。當加上 [!] 時，所有的摺疊都被關閉。對隱
		藏在 {range} 內的所有文本很有用。沒有 [!] 時，關閉一級摺疊。

							*zn*
zn		不摺疊 (none): 復位 'foldenable'。所有的摺疊被打開。

							*zN*
zN		正常摺疊 (normal): 設定 'foldenable'。所有的摺疊都展現它們之前
		的樣子。

							*zi*
zi		翻轉 'foldenable' 的值。


在 折 疊 間 移 動 ~
							*[z*
[z		到當前打開的摺疊的開始。如果已在開始處，移到包含這個摺疊的摺疊
		開始處。如果沒有包含它的摺疊，命令執行失敗。
		當給定計數，重複此命令 [count] 次。

							*]z*
]z		到當前打開的摺疊的結束。如果已在結束處，移到包含這個摺疊的摺疊
		結束處。如果沒有包含它的摺疊，命令執行失敗。
		當給定計數，重複此命令 [count] 次。

							*zj*
zj		向下移動。到達下一個摺疊的開始處。關閉的摺疊也被計入。
		當給定計數，重複此命令 [count] 次。
		此命令可在 |operator| 後使用。

							*zk*
zk		向上移動到前一摺疊的結束處。關閉的摺疊也被計入。
		當給定計數，重複此命令 [count] 次。
		此命令可在 |operator| 後使用。


對 折 疊 執 行 命 令 ~

:[range]foldd[oopen] {cmd}			*:foldd* *:folddoopen*
		對所有不在關閉的摺疊中的行執行 {cmd}。
		給定 [range] 時，僅對範圍內那些行起作用。
		每次命令被執行時，光標會被定位在要被操作的行上。
		就如 ":global" 命令: 首先標記出所有不在關閉的摺疊中的行。然後
		對所有標記過的行，執行 {cmd}。所以當 {cmd} 改變了文本的摺疊
		時，對命令執行的位置沒有影響 (當然，刪除行例外)。
		如: >
			:folddoopen s/end/loop_end/ge
<		使用標誌位 "e" 避免了當 "end" 不匹配時得到錯誤消息。

:[range]folddoc[losed] {cmd}			*:folddoc* *:folddoclosed*
		對所有在關閉的摺疊裏的行，執行 {cmd}。
		其它同 ":folddoopen" 命令。

==============================================================================
3. 摺疊選項					*fold-options*

顏 色							*fold-colors*

對關閉的摺疊的顏色的設定由 Folded 高亮組 |hl-Folded| 決定。對摺疊欄的顏色的設
定由 FolderColumn 高亮組 |hl-FoldColumn| 決定。
下面是設定顏色的例子: >

	:highlight Folded guibg=grey guifg=blue
	:highlight FoldColumn guibg=darkgrey guifg=white
<

折 疊 級 別						*fold-foldlevel*

'foldlevel' 是個數值選項: 數字越大則打開的摺疊更多。
當 'foldlevel' 爲 0 時，所有的摺疊關閉。
當 'foldlevel' 爲正數時，一些摺疊關閉。
當 'foldlevel' 很大時，所有的摺疊打開。
'foldlevel' 的改變後立即生效。之後，摺疊可以被手動地打開和關閉。
當其值增大，在新級別 (譯者注: 舊級別？) 之上的摺疊被打開。手工打開的摺疊不會被
關閉。
當其值減小，在新級別之上的摺疊被關閉。手工關閉的摺疊不會被打開。


折 疊 文 本						*fold-foldtext*

'folftext' 是個字符串選項，定義了一個表達式。這個表達式被用來求得關閉摺疊所顯
示的文字。如: >

    :set foldtext=v:folddashes.substitute(getline(v:foldstart),'/\\*\\\|\\*/\\\|{{{\\d\\=','','g')

顯示了摺疊的第一行，除去其中的 "/*"、"*/" 和 "{{{" 。
備註: 使用反斜槓是爲了避免一些字符被 ":set" 命令解釋。使用一個函數更簡單: >

    :set foldtext=MyFoldText()
    :function MyFoldText()
    :  let line = getline(v:foldstart)
    :  let sub = substitute(line, '/\*\|\*/\|{{{\d\=', '', 'g')
    :  return v:folddashes . sub
    :endfunction

'foldtext' 的計算是在沙盤 |sandbox| 裏完成的。其中的當前窗口設爲要顯示該行的窗
口。錯誤被忽略。

默認值是 |foldtext()|。對於大多數類型的摺疊它可以返回適合的文字。如果你不喜歡
它，你可以自己指定 'foldtext' 表達式。可以使用以下這些 Vim 變量:
	v:foldstart	摺疊首行的行號
	v:foldend	摺疊末行的行號
	v:folddashes	一個含有連字符的字符串，用來表示摺疊級別
	v:foldlevel	摺疊級別

在結果中，製表符被替換爲空格，而不可顯示的字符被替換爲可顯示的字符。

結果行被截短以適合窗口的寬度，永遠不會迴繞。
當在文字後有空餘時，用 'fillchars' 來填充。

備註: 對那些 ":set" 命令作特殊處理的字符在其前面須加上反斜槓。如: 空格，反斜槓
和雙引號。 |option-backslash|


折 疊 欄						*fold-foldcolumn*

'foldcolumn' 是個數字，它設定了在窗口的邊上表示摺疊的欄的寬度。當爲 0 時，沒有
摺疊欄。一個普通值是 4 或 5。最小可用的值是 2，不過 1 仍然可以提供一些信息。最
大是 12。

一個打開的摺疊由一欄來表示，頂端是 '-'，其下方是 '|'。這欄在摺疊結束的地方結
束。當摺疊嵌套時，嵌套的摺疊出現在被包含的摺疊右方一個字符位置。

一個關閉的摺疊由 '+' 表示。

當摺疊欄太窄而不能顯示所有摺疊時，顯示一數字來表示嵌套的級別。

在摺疊欄點擊鼠標，可以打開和關閉摺疊:
- 點擊 '+' 打開在這行的關閉摺疊
- 在任何其他非空字符上點擊，關閉這行上的打開摺疊


其 他 選 項

'foldenable'  'fen':	復位時打開所有摺疊。
'foldexpr'    'fde':	用於 "expr" 摺疊的表達式。
'foldignore'  'fdi':	用於 "indent" 摺疊的字符。
'foldmarker'  'fmr':	用於 "marker" 摺疊的標誌。
'foldmethod'  'fdm':	當前摺疊方法。
'foldminlines' 'fml':	關閉摺疊的最小顯示行數。
'foldnestmax' 'fdn':	用於 "indent" 和 "syntax" 摺疊的最大嵌套層數。
'foldopen'    'fdo':	哪一種命令可以打開關閉的摺疊。
'foldclose'   'fcl':	當光標不在摺疊上時關閉摺疊。

==============================================================================
4. 摺疊行爲						*fold-behavior*

當上下移動和滾動時，光標將移至連續摺疊的行的第一行。當光標已在被摺疊的行上時，
它移動到下一個沒有被摺疊的行上，或下一個關閉的摺疊。

當光標在被摺疊的行上時，光標總是顯示在第一列。標尺顯示確切的光標位置。光標本應
也在實際位置顯示的，但因爲被摺疊而無法做到。

許多移動命令處理連續被摺疊的行就象處理空行一樣。如，"w" 命令只在首列停一次。

在插入模式下，光標所在的行不會被摺疊。這讓你看得見你鍵入的內容。

當使用操作符時，一個關閉的行被作爲整體處理。所以 "dl" 在光標下刪除了整個關閉的
摺疊。

對 Ex 命令的執行範圍被調整，使得它總是從關閉摺疊的第一行開始，在關閉摺疊的最後
一行結束。所以，命令: >
	:s/foo/bar/g
當光標在關閉的摺疊上時，它將在整個摺疊裏用 "bar" 替換 "foo"。
不過 |:folddoopen| 和 |:folddoclosed| 的操作並非如此。

編輯一個已經被編輯過的緩衝區時，上次被使用的摺疊設置會被再次使用。對手工定義折
疊方式，已經被定義的摺疊會被恢復。對所有的摺疊方式，手工打開和關閉的摺疊會被恢
復。如果這個緩衝區曾經在這個窗口裏被編輯，過去用的值被恢復。否則，來自該緩衝區
最近一次編輯的窗口值被使用。

==============================================================================
 vim:tw=78:ts=8:ft=help:norl:
