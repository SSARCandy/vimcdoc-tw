*syntax.txt*	For Vim version 7.4.  最近更新: 2013年8月


		  VIM 參考手冊	  by Bram Moolenaar
				譯者: Willis
				http://vimcdoc.sf.net


語法高亮			*syntax* *syntax-highlighting* *coloring*

語法高亮使得 Vim 可以用不同的字體或顏色顯示文本的不同部分。這些部分可以是特定
的關鍵字，或者匹配某模式的文本。Vim 不會分析整個文件 (爲了保持快速)，所以高亮
功能有其限制。詞法高亮或者是一個更合適的名字，但既然大家都使用語法高亮，我們也
就如此稱呼。

Vim 支持所有終端上的語法高亮。但因爲多數普通的終端只有有限的高亮的選擇，GUI 版
本 gvim 的語法高亮的效果最好。

用戶手冊裏:
|usr_06.txt| 介紹語法高亮。
|usr_44.txt| 介紹如何寫語法文件。

1.  快速入門			|:syn-qstart|
2.  語法文件			|:syn-files|
3.  語法載入過程		|syntax-loading|
4.  語法文件附註		|:syn-file-remarks|
5.  定義語法			|:syn-define|
6.  :syntax 參數		|:syn-arguments|
7.  語法模式			|:syn-pattern|
8.  語法簇			|:syn-cluster|
9.  包含語法文件		|:syn-include|
10. 同步			|:syn-sync|
11. 列出語法項目		|:syntax|
12. Highlight 命令		|:highlight|
13. 鏈接組			|:highlight-link|
14. 清理			|:syn-clear|
15. 高亮標籤			|tag-highlight|
16. 窗口局部語法		|:ownsyntax|
17. 彩色 xterm			|xterm-color|
18. 語法太慢了			|:syntime|

{Vi 無此功能}

如果編譯時關閉了 |+syntax| 特性，就不會有語法高亮的功能。

==============================================================================
1. 快速入門						*:syn-qstart*

						*:syn-enable* *:syntax-enable*
這個命令打開語法高亮: >

	:syntax enable

實際上，它只是執行如下命令 >
	:source $VIMRUNTIME/syntax/syntax.vim

如果沒有設置 VIM 環境變量，Vim 會試圖用其它方法找到該路徑 (見 |$VIMRUNTIME|)。
通常總能找到，如果不行，你可以自己設置 VIM 環境變量爲存放 Vim 相關文件所在的
目錄。例如，如果你的語法文件放在 "/usr/vim/vim50/syntax" 目錄，設置
$VIMRUNTIME 爲 "/usr/vim/vim50"。啓動 Vim 前，你必須在外殼上進行此設置。

							*:syn-on* *:syntax-on*
":syntax enable" 命令會保持你當前的色彩設置。這樣，不管在使用此命令的前後，你
都可以用 ":highlight" 命令設置你喜歡的顏色。如果你希望 Vim 用缺省值覆蓋你自己
的，只要用: >
	:syntax on
<
					*:hi-normal* *:highlight-normal*
如果你運行在 GUI 環境裏，你可以這樣得到黑底白字: >
	:highlight Normal guibg=Black guifg=White
關於色彩終端，見 |:hi-normal-cterm|。
關於設置你自己的語法高亮色彩，見 |syncolor|。

注意: MS-DOS 和 Windows 上的語法文件以 <CR><NL> 結束每一行。Unix 上則以 <NL>
結尾。這意味着你需要爲自己的系統選擇合適的文件。不過，在 MS-DOS 和 Windows
上，如果 'fileformats' 選項非空，會自動選擇正確的格式。

注意: 使用反轉視頻時 ("gvim -fg white -bg black")，'background' 的缺省值直到
GUI 窗口打開時纔會設置。這發生在 |gvimrc| 的讀入之後，從而會使用錯誤的缺省高
亮。要在打開高亮前設置 'background' 的缺省值，在 |gvimrc| 文件裏包含 ":gui" 命
令: >

   :gui		" 打開窗口並設置 'background' 的缺省值
   :syntax on	" 啓動語法高亮，使用 'background' 來設置顏色

注意: 在 |gvimrc| 裏使用 ":gui" 意味着 "gvim -f" 不會在前臺打開！這時，要使用
":gui -f"。

							*g:syntax_on*
你可以用這個命令切換語法的打開/關閉 >
   :if exists("g:syntax_on") | syntax off | else | syntax enable | endif

要把它放到映射裏，你可以用: >
   :map <F7> :if exists("g:syntax_on") <Bar>
	\   syntax off <Bar>
	\ else <Bar>
	\   syntax enable <Bar>
	\ endif <CR>
[使用 |<>| 記法，按本義輸入]

細節:
":syntax" 命令是用執行文件腳本實現的。要瞭解它到底幹了什麼，察看以下文件:
    命令		文件 ~
    :syntax enable	$VIMRUNTIME/syntax/syntax.vim
    :syntax on		$VIMRUNTIME/syntax/syntax.vim
    :syntax manual	$VIMRUNTIME/syntax/manual.vim
    :syntax off		$VIMRUNTIME/syntax/nosyntax.vim
另見 |syntax-loading|。

注意: 如果顯示長行很慢而關閉語法高亮就能加快，考慮設置 'synmaxcol' 選項爲一個
較小的值。

==============================================================================
2. 語法文件							*:syn-files*

某個語言的語法和高亮命令通常存在一個語法文件裏。命名慣例是: "{name}.vim"。其
中，{name} 是語言的名字或者縮寫 (一旦在 DOS 文件系統上，要適用 8.3 字符的名字
限制)。
例如:
	c.vim		perl.vim	java.vim	html.vim
	cpp.vim		sh.vim		csh.vim

語法文件可以包含任何 Ex 命令，就像 vimrc 文件那樣。但應該只有適用於特定語言的
命令才放在裏面。如果該語言是另外一個語言的超集，它可以包含那個語言對應的文件。
例如，cpp.vim 可以包含 c.vim 文件: >
   :so $VIMRUNTIME/syntax/c.vim

.vim 文件通常使用自動命令載入。例如: >
   :au Syntax c	    runtime! syntax/c.vim
   :au Syntax cpp   runtime! syntax/cpp.vim
這些命令通常出現在 $VIMRUNTIME/syntax/synload.vim 文件裏。

如果你有多個文件，可以用文件類型作爲目錄名。該目錄下的所有 "*.vim" 文件都會被
使用。例如:
	~/.vim/after/syntax/c/one.vim
	~/.vim/after/syntax/c/two.vim


創 立 你 自 己 的 語 法 文 件				*mysyntaxfile*

一旦你創立自己的語法文件，並且需要 Vim 在使用 ":syntax enable" 的時候自動調用
它們的時候，按如下操作進行:

1. 建立自己的用戶運行時目錄。通常，把它放在 'runtimepath' 選項的第一項。Unix
的例子: >
	mkdir ~/.vim

2. 在其中建立 "syntax" 目錄。Unix 上: >
	mkdir ~/.vim/syntax

3. 編寫 Vim 語法文件。或者從 internet 下載。然後寫入你的 syntax 目錄。例如，對
於 "mine" 語言的語法: >
	:w ~/.vim/syntax/mine.vim

現在你可以手動啓動語法文件: >
	:set syntax=mine
這時，你並不需要退出 Vim。

如果你想 Vim 也實現文件類型的檢測，見 |new-filetype|。

如果你想爲多個用戶設立系統，而不希望每個用戶增加相同的語法文件的話，可以使用
'runtimepath' 裏的其它目錄。


添 加 到 已 存 在 的 語 法 文 件		*mysyntaxfile-add*

如果你對已有的語法文件大體滿意，只需要增加或者修正一些高亮項目，執行以下步驟即
可:

1. 建立你的 'runtimepath' 裏的用戶目錄，見上。

2. 在那裏建立目錄 "after/syntax"。Unix 上: >
	mkdir ~/.vim/after
	mkdir ~/.vim/after/syntax

3. 編寫 Vim 腳本，包含你希望使用的命令。例如，要在 C 語法裏改變顏色: >
	highlight cComment ctermfg=Green guifg=Green

4. 把該文件寫道 "after/syntax" 目錄。使用該語法的名字，另加上 ".vim"。對於我們
的 C 語法: >
	:w ~/.vim/after/syntax/c.vim

這樣就行了。下一次你編輯 C 文件時，Comment 色彩就不會一樣了。你甚至不需要重啓
Vim。


替 換 已 存 在 的 語 法 文 件			*mysyntaxfile-replace*

如果你不喜歡發佈的語法文件版本，或者你下載了新版本。可以採用上述的
|mysyntaxfile| 相同的步驟。只要確保你寫的語法文件在 'runtimepath' 較早的位置就
可以了。Vim 只會載入第一個找到的語法文件，假定它是用來設置 b:current_syntax 的
那個文件。


命 名 慣 例			    *group-name* *{group-name}* *E669* *W18*

高亮組名用於匹配相同類型事物的高亮項目。它們被鏈接到用於指定顏色的高亮組。語法
組名本身不指定任何顏色或屬性。

高亮或者語法組的名字必須由 ASCII 字母，數字和下劃線組成。如使用正規表達式表示:
"[a-zA-Z0-9_]*"。

要允許每個用戶選擇他自己喜歡的色彩系列，許多語言應該使用相同的高亮組名。以下是
建議的組名 (如果語法高亮能夠正確工作，你應該能看到實際的顏色，除了 "Ignore" 以
外):

	*Comment	v 任何註釋

	*Constant	v 任何常數
	 String		v 字符串常數: "這是字符串"
	 Character	v 字符常數: 'c'、'\n'
	 Number		v 數值常數: 234、0xff
	 Boolean	v 布爾型常數: TRUE、false
	 Float		v 浮點常數: 2.3e10

	*Identifier	v 任何變量名
	 Function	v 函數名 (也包括: 類的方法名)

	*Statement	v 任何語句
	 Conditional	v if、then、else、endif、switch 等
	 Repeat		v for、do、while 等
	 Label		v case、default 等
	 Operator	v "sizeof"、"+"、"*" 等
	 Keyword	v 其它關鍵字
	 Exception	v try、catch、throw

	*PreProc	v 通用預處理命令
	 Include	v 預處理命令 #include
	 Define		v 預處理命令 #define
	 Macro		v 同 Define
	 PreCondit	v 預處理命令 #if、#else、#endif 等

	*Type		v int、long、char 等
	 StorageClass	v static、register、volatile 等
	 Structure	v struct、union、enum 等
	 Typedef	v typedef 定義

	*Special	v 任何特殊符號
	 SpecialChar	v 常數中的特殊字符
	 Tag		v 可以使用 CTRL-] 的項目
	 Delimiter	v 需要注意的字符
	 SpecialComment	v 註釋裏的特殊部分
	 Debug		v 調試語句

	*Underlined	v 需要突出的文本，HTML 鏈接

	*Ignore		v 留空，被隱藏  |hl-Ignore|

	*Error		v 有錯的構造

	*Todo		v 需要特殊注意的部分；主要是關鍵字 TODO FIXME 和 XXX

* 標記的名字是主要組，其它是次要組。對主要組而言，"syntax.vim" 文件包含缺省的
高亮設置。次要組則鏈接到主要組。所以它們擁有相同的高亮設置。不過，你可以通過
":highlight" 命令在 "syntax.vim" 文件之後改變所有組的缺省值。

注意 高亮組的名字對大小寫不敏感。"String" 和 "string" 可用來表示相同的組。

以下名字是保留字，它們不應用作組名:
	NONE   ALL   ALLBUT   contains	 contained

							*hl-Ignore*
如果你使用 Ignore 組，也可以考慮使用隱藏機制。見 |conceal|。

==============================================================================
3. 語法載入過程						*syntax-loading*

這裏解釋命令 ":syntax enable" 執行的細節。Vim 初始化自身時，它尋找運行時文件的
位置。其值用來設置這裏使用的變量 |$VIMRUNTIME|。

":syntax enable" 和 ":syntax on" 完成以下步驟:

    執行 $VIMRUNTIME/syntax/syntax.vim
    |
    +-	清除舊的語法: 執行 $VIMRUNTIME/syntax/nosyntax.vim
    |
    +-	先執行 'runtimepath' 裏的 syntax/synload.vim
    |	|
    |	+-  爲語法高亮設置色彩。如果已經定義了色彩方案，使用 ":colors {name}"
    |   |   再次載入。不然，執行 ":runtime! syntax/syncolor.vim"。":syntax on"
    |   |   會覆蓋已有的顏色，而 ":syntax enable" 只會設置沒有設置過的組。
    |	|
    |	+-  設置 syntax 自動命令，以便在設置 'syntax' 選項時，自動載入合適的語
    |   |   法文件。 *synload-1*
    |	|
    |	+-  通過 |mysyntaxfile| 變量，載入用戶可選的文件。這只是爲了和 Vim 5.x
    |   |   兼容。 *synload-2*
    |
    +-	執行 ":filetype on"，後者又執行 ":runtime! filetype.vim"。它載入任何找
    |   到的 filetype.vim。其中，總會執行 $VIMRUNTIME/filetype.vim。後者執行:
    |	|
    |	+-  根據後綴名，安裝自動命令來設置 'filetype' 選項。這爲已知的文件類型
    |   |   建立了文件名和文件類型的聯繫。 *synload-3*
    |	|
    |	+-  通過 *myfiletypefile* 變量，載入用戶可選的文件。這只是爲了和 Vim
    |   |   5.x 兼容。 *synload-4*
    |	|
    |	+-  安裝自動命令，在沒有檢測到文件類型時執行 scripts.vim 。
    |   |   *synload-5*
    |	|
    |	+-  執行 $VIMRUNTIME/menu.vim，設置 Syntax 菜單。|menu.vim|
    |
    +-	安裝 FileType 自動命令，在檢測到文件類型時，設置 'syntax' 選項。
    |   *synload-6*
    |
    +-	執行 syntax 自動命令，爲每個已經載入的緩衝區啓動語法高亮。


載入文件時，Vim 這樣查找相關的語法文件:

    文件的載入激活 BufReadPost 自動命令。
    |
    +-	如果和 |synload-3| 中的一個自動命令匹配 (已知的文件類型) 或者
    |   |synload-4| (用戶的文件類型)，'filetype' 選項設爲文件的所屬類型。
    |
    +-	如果文件類型沒有找到，激活 |synload-5| 中的自動命令，並在
    |   'runtimepath' 裏找尋 scripts.vim。其中，總是會執行
    |   $VIMRUNTIME/scripts.vim。後者執行以下步驟。
    |	|
    |	+-  通過 *myscriptsfile* 變量，載入用戶可選的文件。這只是爲了和 Vim
    |   |   5.x 兼容。
    |	|
    |	+-  如果文件類型仍然未知，檢查文件的內容，並使用類似於
    |       "getline(1) =~ pattern" 的檢查確定文件類型能否識別，並設置
    |       'filetype'。
    |
    +-	如果文件類型被確定並且設置了 'filetype'，激活 FileType 自動命令，見上
    |   面的 |synload-6|。根據確定的文件類型設置 'syntax'。
    |
    +-	上面設置 'syntax' 選項的步驟激活 |synload-1| (和 |synload-2|) 設置的自
    |   動命令。它會使用以下命令找到 'runtimepath' 裏的主語法文件:
    |		runtime! syntax/<name>.vim
    |
    +-	激活任何用戶安裝的 FileType 或 Syntax 自動命令。這可以用來爲某項語法修
        正高亮方式。

==============================================================================
4. 語法文件附註						*:syn-file-remarks*

						*b:current_syntax-variable*
根據當前激活的是哪部語法，Vim 把載入的語法的名字保存在 "b:current_syntax" 變量
裏。例如: >
   :au BufReadPost * if b:current_syntax == "csh"
   :au BufReadPost *   做一些事
   :au BufReadPost * endif


2HTML						*2html.vim* *convert-to-HTML*

它本身並不是語法文件，只是一個把當前窗口轉換成 HTML 的腳本。Vim 打開一個新窗
口，在那裏它構造 HTML 文件。

保存結果文件以後，你可以使用任何瀏覽器瀏覽。那裏的顏色應該和你在 Vim 裏看到的
一模一樣。|g:html_line_ids| 可使你通過在瀏覽器的地址欄中 URL 尾部加入 (例如)
#L123 或 #123 來跳到指定行。|g:html_dynamic_folds| 則使你可以打開或關閉 Vim 中
的摺疊。

你不應該設置 'filetype' 或 'syntax' 選項爲 "2html"！執行此腳本，以轉換當前文
件: >

	:runtime! syntax/2html.vim
<
許多變量可用來調整 2html.vim 的結果；見下。列出的開關選項可以通過顯式設置其值
來達到打開和關閉的目的，也可以通過用 |:unlet| 刪除變量的方式來恢復其缺省值。

評註:
- 一些真的很老的瀏覽器可能不會顯示背景色。
- 你可以在大多數瀏覽器裏打印文件 (而且有顏色)！
- 本版本的 TOhtml 可以和舊版本的 Vim 共用，但某些功能，例如隱藏 (conceal) 支持
  不會工作，而對編譯時沒有加入 GUI 支持的舊版本，色彩也可能不對。

此處是一個如何在 Unix 外殼上給所有的 .c 和 .h 文件運行此腳本的例子: >
   for f in *.[ch]; do gvim -f +"syn on" +"run! syntax/2html.vim" +"wq" +"q" $f; done
<
					*g:html_start_line* *g:html_end_line*
要限制轉換的行範圍，給下面介紹的 |:TOhtml| 命令加上行範圍，或者設置
"g:html_start_line" 和 "g:html_end_line" 分別爲要轉換的第一行和最後一行。例
如，要指定最近設置的可視區域: >

	:let g:html_start_line = line("'<")
	:let g:html_end_line = line("'>")
	:runtime! syntax/2html.vim
<
							*:TOhtml*
:[range]TOhtml		":TOhtml" 命令在一個標準插件裏定義。該命令爲你執行
			|2html.vim|。給出範圍時，設置 |g:html_start_line| 和
			|g:html_end_line| 分別爲範圍的開始和結束行。缺省範圍是
			整個緩衝區。

			如果窗口處於比較模式，除非置位了
			|g:html_diff_one_file|，:TOhtml 會在生成的 HTML 裏把當
			前標籤頁裏所有參與比較的窗口並排放在一個 <table>
			元素裏。|g:html_line_ids| 還可以允許你跳到指定窗口的指
			定行，(例如) #W1L42 跳到首個參加比較的窗口的第 42 行，
			#W3L87 則是第三個窗口的第 87 行。

			示例: >

	:10,40TOhtml " 把第 10-40 行轉換爲 html
	:'<,'>TOhtml " 轉換當前/最近的可視選擇
	:TOhtml      " 轉換整個緩衝區
<
							*g:html_diff_one_file*
缺省: 0。
爲 0 時，|:TOhtml| 會在生成的 HTML 裏把當前標籤頁裏所有參與比較的窗口並排放在
一個 <table> 元素裏。
爲 1 時，只轉換當前的緩衝區。
示例: >

	let g:html_diff_one_file = 1
<
							 *g:html_whole_filler*
缺省: 0。
爲 0 時，如果 |g:html_diff_one_file| 爲 1，連續多於三行的填充行顯示爲三行，中
間行提示插入的總行數。
爲 1 裏，顯示所有的插入行，這也是 |g:html_diff_one_file| 沒有置位時的行爲。
>
    :let g:html_whole_filler = 1
<
				     *TOhtml-performance* *g:html_no_progress*
缺省: 0。
爲 0 時，2html.vim 轉換的每個主要步驟都會在狀態行上顯示進度條。
爲 1 時，不顯示進度條。會有很不顯著的速度提高，但你無法估計轉換過程要花多長時
間；對大文件而言可能會挺久的！
示例: >

	let g:html_no_progress = 1

通過指示 Vim 以非交互方式運行會得到更好的效率提高，因爲不用在腳本切換緩衝區和
窗口時花時間重畫屏幕，例如: >

  vim -E -s -c "let g:html_no_progress=1" -c "syntax on" -c "set ft=c" -c "runtime syntax/2html.vim" -cwqa myfile.c
<
注意 -s 標誌位停止 .vimrc 和任何插件的載入，因此必須顯式執行/打開影響 HTML
轉換的設置。詳見 |-E| 和 |-s-ex|。最好單獨建一個腳本來代替這裏的 -c 命令，然後
用 -u 標誌位載入之，這樣就不用一個個列出要執行的命令了。

							 *g:html_number_lines*
缺省: 當前的 'number' 設置。
爲 0 時，生成的 HTML 裏顯示緩衝區文本時不帶行號。
爲 1 時，生成的 HTML 里加入行號列，和 Vim 的行號列相同高亮 (|hl-LineNr|) 。
要強制給行編號，即使沒有置位 'number': >
   :let g:html_number_lines = 1
要強制關閉行號: >
   :let g:html_number_lines = 0
要回到缺省情況，即使用 'number' 的設置，可刪除此變量: >
   :unlet g:html_number_lines
<
                                                             *g:html_line_ids*
缺省: 1 如果 |g:html_number_lines| 置位，否則爲 0。
爲 1 時，爲每個行號加上 HTML 的 id 屬性，或者如果行號不顯示，爲同樣的目的加入
一個空的 <span> 。單個緩衝區的 HTML 頁面的 ID 屬性形如 L123，比較視圖的頁面則
形如 W2L123，可以用 ID 來跳轉到該行 (或比較視圖中某個窗口)。同時，加入
Javascript 代碼，在跳到指定行之前打開其所在的已關閉的動態摺疊
(|g:html_dynamic_folds|)。
Javascript 還可以讓你在 url 中省略窗口號或開頭的那個 L。
示例: >

	page.html#L123	跳轉到單個緩衝區文件的第 123 行
	page.html#123	同上

	diff.html#W1L42	跳轉到比較的首個窗口的第 42 行
	diff.html#42	同上
<
							      *g:html_use_css*
缺省: 1。
爲 1 時，生成使用層疊樣式表 (CSS1) 的合法 HTML 4.01 文件，所有的現代瀏覽器和
多數舊式的瀏覽器都支持 CSS1。
爲 0 時，生成 <font> 標籤和類似的過時標記。不推薦，但對真的很老的瀏覽器、電郵
客戶端、論壇帖子和類似不支持基本 CSS 的情形，可能會更好些。
例如: >
   :let g:html_use_css = 0
<
						       *g:html_ignore_conceal*
缺省: 0。
爲 0 時，可隱藏文本被從 HTML 中去除，並取決於 'conceallevel' 的當前值，用
|:syn-cchar| 或 'listchars' 代替。
爲 1 時，在生成的 HTML 中包括所有的緩衝區文本，即使是經過隱藏 (|conceal|)。

以下兩個命令的任何一個都可以確保緩衝區的所有文本都包含在生成的 HTML 裏 (除非有
摺疊的情況): >
   :let g:html_ignore_conceal = 1
   :setl conceallevel=0
<
						       *g:html_ignore_folding*
缺省: 0。
爲 0 時，關閉摺疊裏的實際文本被 Vim 顯示摺疊所用的文本 (|fold-foldtext|) 代
替。如果你還想允許在 HTML 中用戶可以擴展摺疊看到實際文本，就象 Vim 可以做的那
樣的話，另見 |g:html_dynamic_folds|。
爲 1 時，在生成的 HTML 中包括所有的緩衝區文本；不管文本是否在摺疊中都一樣。此
時，|g:html_dynamic_folds| 無效。

以下兩個命令的任何一個都可以確保緩衝區的所有文本都包含在生成的 HTML 裏 (除非有
隱藏 (conceal) 的情況): >
   zR
   :let g:html_ignore_folding = 1
<
							*g:html_dynamic_folds*
缺省: 0。
爲 0 時，生成的 HTML 不包含關閉摺疊裏的文本。
爲 1 時，生成 Javascript 以動態打開摺疊並顯示其中的文本，如同 Vim 那樣。

設置此變量爲 1 時，2html.vim 總是使用 CSS 生成樣式，不管 |g:html_use_css| 的設
置。

|g:html_ignore_folding| 置位時，忽略此變量。
>
   :let g:html_dynamic_folds = 1
<
							*g:html_no_foldcolumn*
缺省: 0。
爲 0 時，如果 |g:html_dynamic_folds| 爲 1，生成摺疊列，如同 vim 的 foldcolumn
(|fold-foldcolumn|) 那樣，用戶點擊該列時切換摺疊的開與關。
爲 1 時，不生成摺疊列；如果置位了 |g:html_hover_unfold|，可以用鼠標移到摺疊文
本來打開摺疊。
>
   :let g:html_no_foldcolumn = 1
<
				*TOhtml-uncopyable-text* *g:html_prevent_copy*
缺省: 空字符串。
如果在瀏覽器中選中生成的 HTML 文檔的全部文本並複製，此選項防止其中部分區域被複
制。此項功能用於保證用戶只複製-粘貼原始的文本，而不包括生成內容顯示的摺疊列或
行號。可以這樣來指定不被複製的區域:
	f:	摺疊列
	n:	行號 (也包括摺疊文本中的)
	t:	摺疊文本
	d:	比較填充行

例如，要使摺疊列和行號不被複製: >
	:let g:html_prevent_copy = "fn"
<
此功能目前的實現方法是插入只讀的 <input> 元素來包圍不想複製的區域。這不總是適
用。若干理解 HTML 的應用還是會粘貼 <input> 元素。但只接受平凡文本的粘貼目標應
該都行。

							   *g:html_no_invalid*
缺省: 0。
爲 0 時，如 |g:html_prevent_copy| 非空，有意地給 <input> 元素插入一個非法的屬
性。這使更多的應用不會粘貼這些 <input> 元素。特別地，Microsoft Word 不會粘貼
有非法屬性的 <input> 元素。
爲 1 時，不會有意插入非法的標記，生成的頁面總是合法的。不過，
|g:html_prevent_copy| 非空時，小心粘貼到 Microsoft Word；一旦粘貼，很難去掉這
些 <input> 元素。

							 *g:html_hover_unfold*
缺省: 0。
爲 0 時，打開 2html.vim 用 |g:html_dynmaic_folds| 設置產生摺疊的唯一方法是點擊
生成的摺疊列。
爲 1 時，用 CSS 2.0 機制，使得用戶把鼠標移到顯示的摺疊文本上時可以打開摺疊。對
不想打開 Javascript 但想看到摺疊文本的用戶會有用。

注意 舊版本的瀏覽器 (尤其是 Internet Explorer 6) 不支持該功能。我們生成 IE6 瀏
覽器特定的 HTML 標記，使之迴歸到普通的 CSS 1 代碼，這樣摺疊還能在此瀏覽器下正
常顯示，但沒有摺疊列它們無法被打開。
>
   :let g:html_hover_unfold = 1
<
							      *g:html_id_expr*
缺省: ""
動態摺疊和行號的跳轉依賴於文檔中生成的 ID 的唯一性。如果生成的 HTML 被複製到更
大的文檔時，ID 的唯一性就很難保證了。設置 |g:html_id_expr| 可以指定一個表達
式，讓 Vim 用來生成唯一的字符串，附加到給定文檔中的每個 ID 之後，以保證生成的
完整 ID 即使和更大的 HTML 文檔的其他內容合並時也保持唯一。例如，要給每個 ID 後
附加 _ 和緩衝區號: >

	:let g:html_id_expr = '"_".bufnr("%")'
<
要給每個 ID 號附加字符串 "_mystring": >

	:let g:html_id_expr = '"_mystring"'
<
注意 轉換比較視圖到 HTML 時，只對比較中的首個窗口計算此表達式，計算結果會用於
所有的窗口。

					  *TOhtml-wrap-text* *g:html_pre_wrap*
缺省: 當前 'wrap' 的設置。
爲 0 時，如果 |g:html_no_pre| 爲 0 或未設，生成的 HTML 中的文本在瀏覽器窗口
邊緣處不迴繞。
爲 1 時，如果 |g:html_use_css| 爲 1，使用 CSS 2.0 的 "white-space:pre-wrap"
值，使文本在瀏覽器窗口邊緣處迴繞。
要顯式打開迴繞: >
   :let g:html_pre_wrap = 1
要關閉迴繞: >
   :let g:html_pre_wrap = 0
迴歸到缺省值，由 'wrap' 設置值來決定迴繞與否: >
   :unlet g:html_pre_wrap
<
							       *g:html_no_pre*
缺省: 0。
爲 0 時，生成的 HTML 用 <pre>...</pre> 標籤來包圍緩衝區文本。連續空格的顯示如
同 Vim 那樣，無需特別標記，製表符也可以按本義使用 (見 |g:html_expand_tabs|)。
爲 1 時 (不推薦)，使用普通的 <div> 代替 <pre> 標籤，用一串 "&nbsp;" 來顯示連續
的空格，<br> 用於結束每行。這是支持生成的 HTML 中文本迴繞的另一個方法，此方法
和舊式的瀏覽器更兼容，但 2html.vim 生成的頁面顯示效果與 Vim 的差別顯著。
>
   :let g:html_no_pre = 1
<
							  *g:html_expand_tabs*
缺省: 1 如果 'tabstop' 爲 8，'expandtab' 爲 0，且生成的 HTML 不用摺疊列或行
	號；
      0 不然。
爲 0 時，緩衝區文本中的 <Tab> 被合適數目的空格，或當 |g:html_no_pre| 爲 1 時，
&nbsp；，所替代。
爲 1 時，如果 |g:html_no_pre| 爲 0 或未設，在生成的 HTML 中保留緩衝區文本中的
<Tab> 字符。這使得瀏覽器中複製粘貼不會丟失原始文檔中的實際空白。注意 除非按照
缺省設置的那些條件，這會很容易打亂 HTML 中文本的對齊和縮進。

強制 |2html.vim| 保留 <Tab> 字符: >
   :let g:html_expand_tabs = 0

強制擴展製表符: >
   :let g:html_expand_tabs = 1
<
				    *TOhtml-encoding-detect* *TOhtml-encoding*
強烈建議用 |g:html_use_encoding| 來爲任何要放到網頁服務器上的內容指定編碼。

如果沒有指定編碼，|2html.vim| 使用 'fileencoding' 的當前值 (如設置) 或者
'encoding' 值的 IANA 的推薦名字來設置。
對某些 'buftype' 類型，總使用 'encoding'。會根據選中的文檔編碼相應的設置
'fileencoding' 的值。

自動檢測適用於所有 |encoding-names| 指定的編碼，但 TOhtml 目前只自動使用那些廣
爲瀏覽器支持的編碼，對缺省不自動檢測的特定編碼，你可以強制其檢測 (見下面的選
項)。IANA 名字可見 http://www.iana.org/assignments/character-sets。

備註，缺省所有 Unicode 編碼所生成的 HTML 會轉化爲不帶 BOM 的 UTF-8，這是 W3C
建議的:

	http://www.w3.org/International/questions/qa-choosing-encodings
	http://www.w3.org/International/questions/qa-byte-order-mark

							 *g:html_use_encoding*
缺省: 無，使用 'fileencoding' 的當前值的 IANA 名字，見上述。
要完全跳過自動字符集檢測，設置 g:html_use_encoding 爲你要使用的字符集。強烈
建議對所有要放上網頁服務器的內容設置此值爲廣爲支持的編碼，如 UTF-8: >
   :let g:html_use_encoding = "UTF-8"
如果不想產生指定字符集的 HTML 行，設置 g:html_use_encoding 爲空字符串 (_不_推
薦): >
   :let g:html_use_encoding = ""
要回到自動的機制，刪除 g:html_use_encoding 變量: >
   :unlet g:html_use_encoding
<
						    *g:html_encoding_override*
缺省: 無，autoload/tohtml.vim 包含 |encoding-names| 中提到名字的編碼的轉換。
如果用 |g:html_use_encoding| 指定的編碼不在缺省的轉換列表中，本選項可以使
|2html.vim| 檢測到正確的 'fileencoding'。

這是個由字符集到編碼的組對所構成的字典，它會替代 TOhtml 自動檢測所生成的相應組
對，或擴充新組對以支持新的字符集。

要檢測 HTML 字符集 "windows-1252" 對應的編碼爲 "8bit-cp1252"，用: >
   :let g:html_encoding_override = {'windows-1252': '8bit-cp1252'}
<
						     *g:html_charset_override*
缺省: 無，autoload/tohtml.vim 包含 |encoding-names| 中提到名字的和有廣泛瀏覽器
		支持的轉換。
本選項指定 |2html.vim| 不能自動檢測的 'fileencoding' 或 'encoding' 所對應的
HTML 字符集。也可用來覆蓋現有的編碼到字符集的組對。例如，
TOhtml 缺省對所有 Unicode/UCS 編碼使用 UTF-8。要用 UTF-16 和 UTF-32 代替之，
用: >
   :let g:html_charset_override = {'ucs-4': 'UTF-32', 'utf-16': 'UTF-16'}

注意 UTF-32 或 UTF-16 編碼的文檔和已知至少一個主要瀏覽器有兼容問題。

			*convert-to-XML* *convert-to-XHTML* *g:html_use_xhtml*
缺省: 0。
爲 0 時，生成標準 HTML 4.01 (如有可能，strict)。
爲 1 時，生成 XHTML 1.0 (XML 兼容的 HTML)。
>
    :let g:html_use_xhtml = 1
<

ABEL						*abel.vim* *ft-abel-syntax*

ABEL 高亮設置提供一些用戶定義的選項。要打開這些選項，給相應的選項設置任意值。
例如: >
	:let abel_obsolete_ok=1
可用 ":unlet" 關閉。例如: >
	:unlet abel_obsolete_ok

變量				高亮 ~
abel_obsolete_ok		廢棄的關鍵字接受爲 statement，而非 error
abel_cpp_comments_illegal	不把 '//' 解釋爲行內註釋的引導符


ADA

見 |ft-ada-syntax|


ANT						*ant.vim* *ft-ant-syntax*

ant 語法文件缺省提供了 javascript 和 python 的語法高亮。其他腳本語言的語法高亮
可以通過 AntSyntaxScript() 函數安裝。它接受的第一個參數是標簽名，而第二個是腳
本語法文件名。例如: >

	:call AntSyntaxScript('perl', 'perl.vim')

會爲下面的 ant 代碼提供 Perl 的語法高亮 >

	<script language = 'perl'><![CDATA[
	    # 這裏的一切都作爲 perl 腳本高亮
	]]></script>

|mysyntaxfile-add| 說明如何永久的安裝腳本語言。


APACHE						*apache.vim* *ft-apache-syntax*

Apache 語法文件提供的語法高亮取決於 Apache HTTP 服務器的版本，缺省爲 1.3.x。設
置 "apache_version" 爲 Apache 的相應版本 (字符串形式) 可以得到其它版本的高亮方
式。例如: >

	:let apache_version = "2.0"
<

		*asm.vim* *asmh8300.vim* *nasm.vim* *masm.vim* *asm68k*
ASSEMBLY	*ft-asm-syntax* *ft-asmh8300-syntax* *ft-nasm-syntax*
		*ft-masm-syntax* *ft-asm68k-syntax* *fasm.vim*

匹配 "*.i" 的可以是 Progress 或者彙編文件。如果自動檢測對你不工作，或者你從來
不編輯 Progress，在你啓動的 vimrc 裏這麼用: >
   :let filetype_i = "asm"
把 "asm" 替換成你實際使用的彙編語言。

許多類型的彙編語言都使用相同的文件擴展名。因而，你或者需要自己選擇類型，或者在
彙編文件裏增加使 Vim 能識別的行。目前，包含了以下的語法文件:
	asm		GNU 彙編 (缺省)
	asm68k		Motorola 680x0 彙編
	asmh8300	Hitachi H-8300 版本的 GNU 彙編
	ia64		Intel Itanium 64
	fasm		Flat 彙編 (http://flatassembler.net)
	masm		Microsoft 彙編 (可能適用於任何 80x86)
	nasm		Netwide 彙編
	tasm		Turbo 彙編 (提供到 Penitum 和 MMX 的 80x86 操作碼)
	pic		PIC 彙編 (目前支持 PIC16F84)

最靈活的方式是在你的彙編文件里加上如下一行: >
	asmsyntax=nasm
把 "nasm" 換成實際的彙編語法的名字。該行必須是文件頭五行中的一行。此文本前後不
能緊接着非空白的其它文本。注意 指定 asmsyntax=foo 等價於在 |modeline| 中設置
ft=foo，如果兩者有衝突，模式行的設置優先 (尤其，如果模式行上有 ft=asm，總是使
用 GNU 的語法高亮，而不管 asmsyntax 如何設置)。

語法類型可以爲某個緩衝區定製。方法是設置 b:asmsyntax 變量: >
	:let b:asmsyntax = "nasm"

如果沒有設置 b:asmsyntax，不管是自動還是手動，就會使用全局變量 asmsyntax 的
值。它可以看作是缺省的彙編語言: >
	:let asmsyntax = "nasm"

如果什麼都沒有定義，最後就假定是 "asm" 語法。


Netwide 彙編器 (nasm.vim) 可選高亮特性 ~

要打開特性: >
	:let   {variable}=1|set syntax=nasm
要關閉特性: >
	:unlet {variable}  |set syntax=nasm

變量			高亮 ~
nasm_loose_syntax	非正式的分析器允許的語法不視爲錯誤 (取決於分析器；不推
			薦)
nasm_ctx_outside_macro	宏之外的上下文不視爲錯誤
nasm_no_warn		潛在有危險的語法不視爲 Todo 那樣的警告


ASPPERL 和 ASPVBS			*ft-aspperl-syntax* *ft-aspvbs-syntax*

*.asp 和 *.asa 文件可以是 Perl 或者 Visual Basic 腳本。因爲很難檢測，你可以設
置兩個全局變量，來告訴 Vim 你要用哪一個。Perl 腳本可用: >
	:let g:filetype_asa = "aspperl"
	:let g:filetype_asp = "aspperl"
Visual Basic 可用: >
	:let g:filetype_asa = "aspvbs"
	:let g:filetype_asp = "aspvbs"


BAAN						    *baan.vim* *baan-syntax*

baan.vim 提供 BaanIV 到 SSA ERP LN 發行版的 BaanC 的語法支持，用於 3 GL 和 4
GL 編程。支持很多的標準宏定義/常數。

如果你在某個 |.vimrc| 裏指定下面這行，不合編碼標準的一些特殊錯誤會被報告: >
	let baan_code_stds=1

*baan-folding*

使用下面提到的變量，可以在不同層次上打開語法摺疊 (在 |.vimrc| 裏設置)。源代碼
塊和 SQL 上越複雜的摺疊越需要 CPU。

要允許摺疊並在函數級別上打開摺疊: >
	let baan_fold=1
可以在源代碼塊級別上打開摺疊，如 if、while、for，... 這裏開始/結束關鍵字之前的
縮進必須一致 (空格不等於製表)。 >
	let baan_fold_block=1
可以爲內嵌的 SQL 塊打開摺疊，如 SELECT、SELECTDO、SELECTEMPTY，... 這裏開始/結
束關鍵字之前的縮進必須一致 (空格不等於製表)。 >
	let baan_fold_sql=1
<
注意: 代碼塊級別的摺疊可能產生許多小的摺疊。建議在 .vimrc 裏用 |:set| 設置選項
'foldminlines' 和 'foldnestmax'，在 .../after/syntax/baan.vim 裏用 |:setlocal|
設置也可以 (見 |after-directory|)。例如: >
	set foldminlines=5
	set foldnestmax=6


BASIC			*basic.vim* *vb.vim* *ft-basic-syntax* *ft-vb-syntax*

Visual Basic 和 "普通的" Basic 都使用擴展名 ".bas"。要檢測使用的是哪一個，Vim
在文件的頭五行檢查字符串 "VB_Name"。如果沒找到，文件類型將是 "basic"，不然就是
"vb"。帶 ".frm" 擴展名的文件總被視爲 Visual Basic 類型。


C							*c.vim* *ft-c-syntax*

C 高亮的一些設置是可選的。要打開，給相應的變量賦任何值。例如: >
	:let c_comment_strings = 1
可用 ":unlet" 關閉。例如: >
	:unlet c_comment_strings

變量			高亮 ~
c_gnu			GNU gcc 專用的項目
c_comment_strings	註釋裏的字符串和數字
c_space_errors		行尾的空格和 <Tab> 之前的空格
c_no_trail_space_error	 ... 不包括行尾的空格
c_no_tab_space_error	 ... 不包括 <Tab> 之前的空格
c_no_bracket_error	不高亮 {}；如果在 [] 裏面視爲錯誤
c_no_curly_error	不高亮 {}；如果在 [] 和 () 裏面視爲錯誤；
				除了出現在首列的 { 和 } 以外
c_curly_error		高亮丟失的 }；強制從文件首開始同步，因而可能會較慢
c_no_ansi		不使用 ANSI 標準類型和常數
c_ansi_typedefs		 ... 但使用 ANSI 標準類型
c_ansi_constants	 ... 但使用 ANSI 標準常數
c_no_utf		不高亮字符串裏的 \u 和 \U
c_syntax_for_h		*.h 文件使用 C 語法，而不是 C++ 的，用 objc 語法，而不
			是 objcpp 的
c_no_if0		不把 "#if 0" 塊高亮爲註釋
c_no_cformat		不高亮字符串裏的 %-格式
c_no_c99		不高亮 C99 標準的項目
c_no_c11		不高亮 C11 標準的項目

如果 'foldmethod' 設爲 "syntax"，那麼 /* */ 註釋和 { } 塊成爲摺疊。如果你不想
讓註釋成爲摺疊: >
	:let c_no_comment_fold = 1
"#if 0" 塊也被摺疊，除非: >
	:let c_no_if0_fold = 1

如果你注意到往回滾動時，高亮出現問題，但 CTRL-L 重畫又可以修正的話，嘗試設置
"c_minlines" 內部變量爲較大的值: >
	:let c_minlines = 100
這使得語法同步在第一個顯示行之前的 100 行開始。缺省值爲 50 (如果設置了
c_no_if0，則爲 15)。使用較大的值的缺點是重畫會變慢。

如果使用 "#if 0" / "#endif" 風格的註釋高亮，注意它只適用於 "#if 0" 出現在窗口
頂部往上不超過 "c_minlines" 行的場合。如果你有很長的 "#if 0" 構造，它不會被正
確地高亮。

要匹配註釋裏的附加項目，使用 cCommentGroup 簇。例如: >
   :au Syntax c call MyCadd()
   :function MyCadd()
   :  syn keyword cMyItem contained Ni
   :  syn cluster cCommentGroup add=cMyItem
   :  hi link cMyItem Title
   :endfun

ANSI 常數使用 "cConstant" 組高亮。這包括 "NULL"、"SIG_IGN" 還有其它。但不包
括，比如說，"TRUE"。因爲它不在 ANSI 標準裏。如果你覺得弄不清楚，刪除 cConstant
高亮: >
	:hi link cConstant NONE

如果你看到 '{' 和 '}' 被高亮爲錯誤，而實際並非如此的時候，復位 cErrInParen 和
cErrInBracket 的高亮。

如果想在你的 C 文件裏使用摺疊，可以在 'runtimpath' 的 "after" 目錄下的一個文件
里加上這些行。Unix 上，這會是 ~/.vim/after/syntax/c.vim. >
    syn sync fromstart
    set foldmethod=syntax

CH						*ch.vim* *ft-ch-syntax*

C/C++ 解釋器。Ch 的語法高亮和 C 相似，它基於 C 語法文件。|c.vim| 說明所有 C 可
用的設置。

設置此變量，告訴 Vim 用 Ch 語法來處理 *.h 文件，而不是 C 或 C++ 語法: >
	:let ch_syntax_for_h = 1


CHILL						*chill.vim* *ft-chill-syntax*

Chill 語法高亮和 C 類似。可用的設置見 |c.vim|。此外，還有:

chill_space_errors	類似於 c_space_errors
chill_comment_string	類似於 c_comment_strings
chill_minlines		類似於 c_minlines


CHANGELOG				*changelog.vim* *ft-changelog-syntax*

ChangeLog 支持行首的空格高亮。如果你不喜歡，在你的 .vimrc 里加入下行: >
	let g:changelog_spacing_errors = 0
下次你編輯 changelog 文件時，就會應用。你也可以使用
"b:changelog_spacing_errors" 來爲每個緩衝區分別設置 (在載入語法文件以前)。

你可以改變現在使用的高亮，例如把空格標記爲錯誤: >
	:hi link ChangelogError Error
或者避免高亮: >
	:hi link ChangelogError NONE
這些會立即生效。


COBOL						*cobol.vim* *ft-cobol-syntax*

COBOL 高亮對傳統的代碼和新開發的代碼有不同的需要。這來自於需求的差異 (維護還是
開發)，以及一些其它因素。要使用傳統代碼的高亮，在 .vimrc 里加上此行: >
	:let cobol_legacy_code = 1
要再次關閉，可用: >
	:unlet cobol_legacy_code


COLD FUSION			*coldfusion.vim* *ft-coldfusion-syntax*

ColdFusion 有 HTML 註釋的自己的版本。要打開 ColdFusion 風格的註釋高亮，在你的
啓動文件里加上此行: >

	:let html_wrong_comments = 1

ColdFusion 語法文件是基於 HTML 的語法文件的。


CPP						*cpp.vim* *ft-cpp-syntax*

多數設置同 |ft-c-syntax|。

變量			特色 ~
cpp_no_c11		不高亮 C++11 標準項目


CSH						*csh.vim* *ft-csh-syntax*

這裏討論名爲 "csh" 的外殼。注意 有的系統實際使用的是 tcsh。

要檢測一個文件是 csh 還是 tcsh 異常困難。有的系統把 /bin/csh 符號鏈接到
/bin/tcsh，使得區別 csh 和 tcsh 幾乎不可能。如果 VIM 猜錯，你可以自己設置
"filetype_csh" 變量。要使用 csh:  *g:filetype_csh*
>
	:let g:filetype_csh = "csh"

要使用 tcsh: >

	:let g:filetype_csh = "tcsh"

帶 tcsh 擴展名的腳本或者 tcsh 的標準文件名 (.tcshrc、tcsh.tcshrc、tcsh.login)
會使用文件類型 tcsh。其它的 tcsh/csh 腳本也會被識別爲 tcsh，_除非_存在
"filetype_csh" 變量。如果存在 "filetype_csh" 變量，文件類型會設爲該變量的值。


CYNLIB						*cynlib.vim* *ft-cynlib-syntax*

Cynlib 文件是使用 Cynlib 類庫的 C++ 文件。它們使用 C++ 來爲硬件建模和模擬。通
常 Cynlib 文件使用 .cc 或 .cpp 擴展名，這使得它們和普通的 C++ 文件難以區別。因
而，要使用 Cynlib 爲 .cc 文件高亮，在你的 .vimrc 文件里加上此行: >

	:let cynlib_cyntax_for_cc=1

cpp 文件也類似 (該擴展名通常爲 Windows 使用) >

	:let cynlib_cyntax_for_cpp=1

要再次關閉，可用: >

	:unlet cynlib_cyntax_for_cc
	:unlet cynlib_cyntax_for_cpp
<

CWEB						*cweb.vim* *ft-cweb-syntax*

匹配 "*.w" 的文件可爲 Progress 文件或者 cweb 文件。如果自動檢測不行，或者你從
來不編輯 Progress，可以在啓動的 vimrc 文件裏用: >
   :let filetype_w = "cweb"


DESKTOP					   *desktop.vim* *ft-desktop-syntax*

該語法文件的主要目的是根據 freedesktop.org 標準:
http://standards.freedesktop.org/desktop-entry-spec/latest/
來高亮 .desktop 和 .directory 文件。但實際上，幾乎沒人完全實現了標準。所以，它
實際被用來高亮所有的 Unix ini 文件。如果你希望強制使用符合標準的嚴格的高亮方
式，在 vimrc 文件放上: >
	:let enforce_freedesktop_standard = 1


DIRCOLORS			       *dircolors.vim* *ft-dircolors-syntax*

dircolors 工具的高亮定義有一個選項。它的存在是爲了和 Slackware GNU/Linux 發佈
版本里的該命令兼容。它增加了一些多數版本忽略的關鍵字。在 Slackware 系統中，該
工具接受這些關鍵字並在處理中應用。要允許使用 Slackware 關鍵字，在你的啓動文件
里加入如下一行: >
	let dircolors_is_slackware = 1


DOCBOOK					*docbk.vim* *ft-docbk-syntax* *docbook*
DOCBOOK XML				*docbkxml.vim* *ft-docbkxml-syntax*
DOCBOOK SGML				*docbksgml.vim* *ft-docbksgml-syntax*

有兩種類型的 DocBook 文件: SGML 和 XML。要指定使用那種類型，需要設置
"b:docbk_type" 變量。如果 Vim 能夠識別，它會自動設置該變量。如果 Vim 猜不到，
缺省的類型是 XML。
你可以手動設置: >
	:let docbk_type = "sgml"
或者: >
	:let docbk_type = "xml"
你需要在載入語法文件前作如此設置，這有點複雜。
更簡單的方法是設置文件類型爲 "docbkxml" 或 "docbksgml": >
	:set filetype=docbksgml
或: >
	:set filetype=docbkxml

可以指定 DocBook 版本: >
	:let docbk_ver = 3
如無指定假定爲 4。

DOSBATCH				*dosbatch.vim* *ft-dosbatch-syntax*

DOS 批處理文件的高亮有一個選項。它和 Windows 2000 的命令解釋器的新擴展有關，可
以通過 dosbatch_cmdextversion 變量控制。Windows NT 上，它應該取值爲 1，Windows
2000 應該爲 2。下面這行可以選擇你想要的版本: >

   :let dosbatch_cmdextversion = 1

如果沒有定義該變量，缺省設爲 2，以支持 Windows 2000 版本。

第二個選項控制 *.btm 文件是否被識別爲 "dosbatch" 類型 (MS-DOS 批處理文件) 或
"btm" 類型 (4DOS 批處理文件)。缺省使用後者。下行可以讓你選擇前者: >

   :let g:dosbatch_syntax_for_btm = 1

如果此變量無定義或爲零，選擇 btm 語法。



DOXYGEN						*doxygen.vim* *doxygen-syntax*

Doxygen 使用特殊的文檔格式生成代碼文檔 (和 Javadoc 類似)。本語法腳本爲 c、
cpp、idl 和 php 文件加入 Doxygen 的高亮，Java 應該也能用。

有幾個辦法可以打開 Doxygen 格式。首先，在文件的模式行上可以給 syntax 加入
".doxygen"，進行顯式設置。示例: >
	:set syntax=c.doxygen
或 >
	// vim:syntax=c.doxygen

對於 C、C++、C#、IDL 和 PHP 文件，也可以設置全局或局部於緩衝區變量
load_doxygen_syntax 來自動完成這個操作。在 .vimrc 里加上 >
	:let g:load_doxygen_syntax=1

有一些變量影響語法高亮，它們大多和非標準的高亮選項有關。

變量				缺省	效果 ~
g:doxygen_enhanced_color
g:doxygen_enhanced_colour	0	Doxygen 註釋使用非標準的高亮。

doxygen_my_rendering		0	關閉 HTML 粗體、斜體和
					html_my_rendering 下劃線的高亮。

doxygen_javadoc_autobrief	1	如果爲 0，關閉 Javadoc autobrief 色彩
					高亮。

doxygen_end_punctuation		'[.]'	匹配 brief 結束標點的正規表達式。

還有一些高亮組值得提提，你可以對它們進行配置。

高亮				效果 ~
doxygenErrorComment		如果 code、verbatim 或 dot 段裏丟失標點，註釋
				尾部的顏色。
doxygenLinkError		如果丟失 \link 段的 \endlink，註釋尾部的顏色。


DTD						*dtd.vim* *ft-dtd-syntax*

DTD 語法高亮缺省是大小寫敏感的。如果不想如此，在你的啓動文件里加入以下一行: >

	:let dtd_ignore_case=1

DTD 語法會把未知的標籤高亮爲錯誤。如果這很討厭，在執行 dtd.vim 語法文件之前，
可以用以下設置來關閉: >

	:let dtd_no_tag_errors=1

參數實體 (parameter entity) 的名字使用 'Type' 高亮組高亮，標點和 '%' 使用
'Comment'。參數實體的實例使用 'Constant' 高亮組高亮，定界符 % 和 ; 則使用
'Type' 高亮組。以下設置可以關閉這些設定: >

	:let dtd_no_param_entities=1

xml.vim 也包含了 DTD 語法文件，用以高亮內嵌的 dtd。

EIFFEL					*eiffel.vim* *ft-eiffel-syntax*

儘管 Eiffel 不是大小寫敏感的，它的風格指南鼓勵如此，而且語法高亮文件也鼓勵這樣
使用。這使得同一類名的高亮可以不同。如果你想關閉大小寫敏感的語法高亮，在啓動文
件里加上這行: >

	:let eiffel_ignore_case=1

大小寫對類名和註釋裏的 TODO 標記仍然有影響。

相反，要更嚴格的檢查，加入以下諸行之一: >

	:let eiffel_strict=1
	:let eiffel_pedantic=1

設置 eiffel_strict 只會捕獲以下五個預定義的單詞錯誤的大小寫: "Current"、
"Void"、"Result"、"Precursor" 和 "NONE"。用於警告它們可能被不小心用作特性或類
名。

設置 eiffel_pedantic 會非常嚴格地遵循 Eiffel 風格指南 (例如，大小寫字母的任意
混合和其它過時的大寫關鍵字的方法都會被捕獲)。

如果希望使用小寫版本的 "Current"、"Void"、"Result" 和 "Precursor"，可以用 >

	:let eiffel_lower_case_predef=1

而不用完全關閉大小寫敏感的高亮方式。

一些編譯器裏已經能夠實驗性地處理 ISE 推薦的新的創建語法，要打開此語法: >

	:let eiffel_ise=1

最後，有的供應商支持十六進制的常數。在你的啓動文件里加上這行就可以處理它們 >

	:let eiffel_hex_constants=1


ERLANG						*erlang.vim* *ft-erlang-syntax*

Erlang 是 Ericsson 開發的函數編程語言。下列文件後綴被識別爲 Erlang 文件: erl、
hrl、yaws。

缺省打開 BIF (內建函數) 的高亮。要關閉之，在 .vimrc 里加上: >

	:let g:erlang_highlight_bifs = 0

要打開某些特殊原子 (atom) 的高亮，在 .vimrc 里加上: >

	:let g:erlang_highlight_special_atoms = 1


FLEXWIKI				*flexwiki.vim* *ft-flexwiki-syntax*

FlexWiki 是基於 ASP.NET 的 wiki 包，從 http://www.flexwiki.com 可以獲得。
備註: 此網站已不可用，Wikipedia 指出開發已在 2009 年停止。

多數常用的 FlexWiki 語法元素都提供了語法高亮。本文件類型插件腳本設置了若干局部
於緩衝區的選項，使 FlexWiki 頁面的編輯更加便捷。因爲 FlexWiki 把換行符看成新段
落的開始，所以本插件設置 'tw'=0 (無限行長)，置位 'wrap' (迴繞長行而不使用水平
滾動)，也置位 'linebreak' (在 'breakat' 包含的字符而不是在屏幕最後一個字符上回
繞)，等等。本插件也包含了一些鍵盤映射，但它們缺省是關閉的。

如果你打開鍵盤映射，"j" 和 "k" 和光標鍵就會在顯示行間上下移動。爲此，在 .vimrc
里加入: >
	:let flexwiki_maps = 1


FORM						*form.vim* *ft-form-syntax*

FORM 文件裏的語法元素的色彩方案使用缺省模式: Conditional、Number、Statement、
Comment、PreProc、Type 和 String。它遵循 1991 年版荷蘭 CAN 組織
J.A.M. Vermaseren 編著的語言說明書 'Symbolic Manipulation with FORM'。

如果你想自己增加對缺省顏色的修改，需要重新定義以下語法組:

    - formConditional
    - formNumber
    - formStatement
    - formHeaderStatement
    - formComment
    - formPreProc
    - formDirective
    - formType
    - formString

注意 缺省，form.vim 語法文件使用相同的語法組裏實現 FORM 預處理器命令和指令。

預定義的 FORM 增強色彩模式可以用來區別頭部語句和 FORM 程序本體的語句。要激活此
模式，在你的 vimrc 文件裏定義以下變量 >

	:let form_enhanced_color=1

在深色 gvim 顯示中，增強模式也利用了附加的色彩特性。這裏，語句
(formStatement) 使用 LightYellow 而不是 Yellow。而條件句 (formConditional) 使
用 LightBlue，以達到更好的區分度。


FORTRAN					*fortran.vim* *ft-fortran-syntax*

缺省高亮方式和方言 ~
缺省使用適合 Fortran 2008 的高亮方式。這樣的選擇應該適用於絕大多數的用戶，因爲
Fortran 2008 幾乎是以前所有版本的超集 (Fortran 2003、95、90 和 77)。

Fortran 源代碼形式 ~
Fortran 代碼可以使用固定寬度的源代碼，也可以使用自由形式。注意如果形式設置錯
誤，語法高亮也不會正確。

創建新的 Fortran 文件時，語法腳本假定使用的是固定寬度的源代碼。如果你總是使用
自由形式，那麼在你的 .vimrc 裏，把 >
    :let fortran_free_source=1
放在 :syntax 命令前。如果你總是使用固定寬度格式，那麼在你的 .vimrc 裏，把 >
    :let fortran_fixed_source=1
放在 .syntax 命令前。

如果源代碼的格式取決於文件擴展名，那麼最方便的方法是在 ftplugin 文件裏設置
fortran_free_source。見 |ftplugin|。例如，假定你所有的使用 .f90 擴展名的
Fortran 文件使用自由形式編寫，而其它的則使用固定寬度，那麼在你的 ftplugin 文件
里加上以下的行 >
    let s:extfname = expand("%:e")
    if s:extfname ==? "f90"
	let fortran_free_source=1
	unlet! fortran_fixed_source
    else
	let fortran_fixed_source=1
	unlet! fortran_free_source
    endif
注意，要使之工作，你需要在 .vimrc 文件的 "syntax on" 命令前加上 "filetype
plugin indent on" 命令。

編輯已有的 Fortran 文件時，如果定義了 fortran_free_source 變量，語法腳本假定使
用自由形式，如果定義了 fortran_fixed_source 變量，則假定使用固定寬度形式。如果
兩者都沒有，語法腳本檢驗文件的頭 250 行的頭 5 列。如果沒有發現自由形式的跡象，
那麼假定文件爲固定寬度形式的源文件。這個算法應該在絕大多數情況下適用。有的情況
下，比如文件的開始有 250 行或更多完整行的註釋，該腳本也許會錯誤地認爲該
Fortran 代碼使用的是固定寬度形式。如果此種情況真的發生，只要在前 250 行的頭 5
列裏的任何地方加上一個非註釋的語句，然後保存 (:w) 並重新讀入 (:e!) 文件就可以
了。

Fortran 文件裏的製表鍵 ~
Fortran 標準不識別製表鍵。在固定寬度格式的 Fortran 源代碼裏，製表不是一個好主
意，因爲需要固定的列邊界。因此，製表被識別爲錯誤。不過，有的程序員喜歡使用制
表。如果你的 Fortran 文件裏包含製表，那麼需要在 .vimrc 裏使用這樣的命令來設置
變量 fortran_have_tabs >
    :let fortran_have_tabs=1
並把它放在 :syntax 命令之前。不幸的是，製表的使用意味着語法文件無法識別不正確
的邊界。

Fortran 文件的語法摺疊~
如果你希望使用 foldmethod=syntax，那麼你需要先使用命令設置變量 fortran_fold >
    :let fortran_fold=1
來指示語法腳本爲程序單元定義摺疊區域。程序單元 (program unit) 包括程序語句開始
的主程序、子例程、函數子程序、塊數據子程序、接口塊和模塊。如果你也使用如下命令
設置變量 fortran_fold_conditionals >
    :let fortran_fold_conditionals=1
那麼也會爲 do 循環、if 塊和 select case 構造定義摺疊區域。如果你同時使用如下命
令設置變量 fortran_fold_multilinecomments >
    :let fortran_fold_multilinecomments=1
那麼還會爲三行或更多連續的註釋定義摺疊區域。注意 定義摺疊區域會使大文件變慢。

如果設置了 fortran_fold 和可能的 fortran_fold_conditionals 與/或
fortran_fold_multilinecomments，vim 會在你使用 foldmethod=syntax 時摺疊文件。
兩個程序單元之間的註釋或空行不會被摺疊，因爲它們不被視作任何一個程序單元的一部
分。

更精確的 Fortran 語法 ~
如果使用如下命令設置變量 fortran_more_precise >
    :let fortran_more_precise=1
那麼語法高亮會更精確，但也更慢。特別是，能夠識別 do、goto 和算術 if 語句使用的
語句標籤，還有 do、if、select、或 forall 構造結尾的構造名。

非缺省的 Fortran 方言 ~
本語法腳本支持兩種 Fortran 方言: f08 和 F。缺省高亮方式 (f08) 基本令人滿意。一
些 2008 標準宣告過時或刪除的傳統結構被高亮爲 todo 項目。

如果你使用 F，設置合適的方言的優點包括，F 排除的傳統特性會被高亮爲 todo 項目；
還有，總是假定使用自由形式的源程序。

有幾個方式選擇方言。如果你所有的 Fortran 文件使用相同的方言，在你的 .vimrc 文
件裏 syntax 命令之前設置 fortran_dialect。可以接受的 fortran_dialect 的值是大
小寫敏感的，而且必須是 "f08" 或 "F"。不合法的 fortran_dialect 的值被忽略。

如果源代碼的格式取決於文件擴展名，那麼最方便的方法是在 ftplugin 文件裏設置一個
緩衝區局部變量。關於 ftplugin 文件的詳情，見 |ftplugin|。例如，如果你使用 .f90
擴展名的所有 Fortran 文件都使用 F 子集，那麼在你的 ftplugin 文件裏應該包含代碼
>
    let s:extfname = expand("%:e")
    if s:extfname ==? "f90"
	let b:fortran_dialect="F"
    else
	unlet! b:fortran_dialect
    endif
<
注意 只有在你的 .vimrc 文件的 "syntax on" 命令前加上了
"filetype plugin indent on" 命令，才能使這段代碼工作。

如果文件擴展名還不能唯一確定方言，那麼你需要更精細的控制。可以爲每個文件定製方
言。方法是在文件的頭三行內加上指令 "fortran_dialect=xx" (其中 xx=F 或 f08)。例
如，你較老的 .f 文件可能用傳統代碼編寫，但較新的那些可能使用 F，那麼你需要在後
者每個文件的頭三行內加上以下形式的 Fortran 註釋，以便標識 >
  ! fortran_dialect=F

使用較早的語法版本的用戶，可能會設置 fortran_dialet 爲現已廢棄的值 "f77"、
"f90"、"f95" 或 "elf"。這些設置都會被悄悄地當作 "f08" 處理。"elf" 用戶可能想
試試 "F" 也許會更好。

syntax/fortran.vim 腳本包含內嵌註釋，說明如何爲某些行加上註釋和/或去掉註釋來
(a) 識別一些非標準廠商自定的內在過程 (intrinsic)，(b) 使某些 2008 標準刪除或廢
止的功能不採用 todo 項目高亮。

限制 ~
括號檢查不能發現過少的閉括號。也不能識別 Hollerith 字符串。有些關鍵字可能高亮
不正確，因爲 Fortran90 沒有保留字。

更多關於 Fortran 的信息可見 |ft-fortran-indent| 和 |ft-fortran-plugin|。


FVWM 配 置 文 件 				*fvwm.vim* *ft-fvwm-syntax*

要使得 Vim 識別不符合模式 *fvwmrc* 或 *fvwm2rc* 的 Fvwm 配置文件，你需要在你
myfiletypes.vim 文件裏放入附加適合你系統的模式。對於這些模式，你需要設置變量
"b:fvwm_version" 爲 Fvwm 的主版本號，同時設置 'filetype' 選項爲 fvwm。

例如，要使 Vim 識別 /etc/X11/fvwm2/ 裏的所有文件爲 Fvwm2 的配置文件，可以這樣
設置: >

  :au! BufNewFile,BufRead /etc/X11/fvwm2/*  let b:fvwm_version = 2 |
					 \ set filetype=fvwm

如果你想讓 Vim 高亮所有的合法顏色名，告訴它如何找到在你的系統上顏色數據庫
(rgb.txt)。設置 "rgb_file" 指向該文件就可以了。假如你的顏色數據庫在
/usr/X11/lib/X11/，加入下行 >

	:let rgb_file = "/usr/X11/lib/X11/rgb.txt"

到你的 .vimrc 文件裏。


GSP						*gsp.vim* *ft-gsp-syntax*

GSP 頁面的缺省色彩風格由 |html.vim| 定義，而 Java 代碼 (在 Java 標籤裏或反引號
之間的內含代碼) 的顏色由 |java.vim| 定義。 |html.vim| 裏定義的以下 HTML 組在這
裏被重新定義，以配合高亮的內含 (inline) Java 代碼:

    htmlString
    htmlValue
    htmlEndTag
    htmlTag
    htmlTagN

多數你看到內含 Java 代碼的地方，高亮應該沒問題，但在一些特殊情況下可能有問題。
要加入其它可包含內含 Java 代碼而高亮不正確的 HTML 組，只要從 |html.vim| 裏把你
想要的行複製出來，並在 contains 子句里加上 gspJava 就可以了。

反引號裏的內含 Java 使用 htmlError 組高亮，使之更易看清。


GROFF						*groff.vim* *ft-groff-syntax*

groff 語法文件是 |nroff.vim| 的包裝，見該標題下的說明參閱使用和配置的示例。提
供這個包裝的目的是通過 |modeline| 或個人的文件類型文件 (見 |filetype.txt|) 來
設置文件類型，從而設置 groff 專用的語法擴展。


HASKELL			     *haskell.vim* *lhaskell.vim* *ft-haskell-syntax*

Haskell 語法文件支持普通的 Haskell 代碼和文學的 (literate) Haskell 代碼，後者
包括 Bird 風格和 Tex 風格。Haskell 語法高亮也能高亮 C 預處理指令。

如果你想高亮定界符 (適用於淺色背景)，在 .vimrc 里加上: >
	:let hs_highlight_delimiters = 1
要把 True 和 False 識別爲關鍵字而不是普通的標識符，加上: >
	:let hs_highlight_boolean = 1
要把基本類型的名字識別爲關鍵字: >
	:let hs_highlight_types = 1
要把更多相對常用的類型識別爲關鍵字: >
	:let hs_highlight_more_types = 1
如果想高亮調試函數的名字，在你的 .vimrc 里加上: >
	:let hs_highlight_debug = 1

Haskell 語法高亮也高亮 C 預處理指令，但非法的 # 開始的指令被標記爲錯誤。這和
Haskell 的操作符語法有衝突，因爲它們可能會用 # 開始。如果你想高亮這些爲操作符
而不是錯誤，在 .vimrc 里加入: >
	:let hs_allow_hash_operator = 1

文學的 Haskell 代碼的語法高亮會試圖自動猜測你的文學 Haskell 代碼是否包含 Tex
標記，並相應地高亮 Tex 構造或什麼也不做。要在全局改變此行爲，在你的 .vimrc 文
件裏放上 >
	:let lhs_markup = none
就可完全關閉高亮。或者 >
	:let lhs_markup = tex
強制使用 Tex 標記風格的高亮。更靈活的方法是使用該變量的局部於緩衝區的版本，例
如 >
	:let b:lhs_markup = tex
會強製爲特定的緩衝區使用 TeX 高亮。必須在該緩衝區打開語法高亮或者載入文件前設
置。


HTML						*html.vim* *ft-html-syntax*

HTML 文件裏，標籤的色彩方案工作方式如下。

開放標籤的 <> 和關閉標籤的 </> 的顏色不同。這是有意的！開放標籤使用 'Function'
色，而關閉標籤使用 'Type' 色 (察看 syntax.vim 瞭解它們是如何爲你定義的)。

已知的標簽名使用 C 語句 (Statement) 的色彩。未知的標簽名分別和相應的 <> 或 </>
顏色相同，以便糾錯。

注意 這同樣適用於參數 (或屬性) 名。已知的屬性名和未知的顏色不同。

一些 HTML 標籤用於改變文本的顯示。html.vim 語法色彩文件識別以下的標籤，並相應
地改變普通文本的顯示方式: <B> <I> <U> <EM> <STRONG> (<EM> 是 <I> 的別名，而
<STRONG> 是 <B> 的別名)，<H1> - <H6>，<HEAD>，<TITLE> 和 <A> (<A> 必須在作爲鏈
接，即包含了 href，纔會如此。如 <A href="somefile.html">)。

如果你想改變文本顯示的方式，必須重定義以下的語法組:

    - htmlBold
    - htmlBoldUnderline
    - htmlBoldUnderlineItalic
    - htmlUnderline
    - htmlUnderlineItalic
    - htmlItalic
    - htmlTitle 設定標題
    - htmlH1 - htmlH6 設定標題頭部 (header) 的文本

要使得重定義能夠工作，你必須重定義所有的組，最後兩組 (htmlTitle 和 htmlH[1-6]
可選) 可以除外。在你的 vimrc (這是根據初始化時讀入文件的順序) 裏定義下面的變量
>
	:let html_my_rendering=1

要想看一個例子，下載 http://www.fleiner.com/vim/download.html 的 mysyntax.vim
文件。

在你的 vimrc 文件里加上這行，可以屏蔽這種顯示方式: >
	:let html_no_rendering=1

HTML 註釋相當特別 (詳情見 HTML 的參考文檔)，此語法高亮方案會高亮所有的錯誤。不
過，如果你喜歡不太正確 (以 <!-- 開始並以 --!> 結束) 的風格，可以定義 >
	:let html_wrong_comments=1

HTML 文檔的內嵌 (embedded) JavaScript 和 Visual Basic 使用 'Special' 高亮，而
其中的語句、註釋、字符串等使用標準的編程語言的顏色。注意 現在只支持 JavaScript
和 Visual Basic，還沒有加入其它的腳本語言。

內嵌和內含 (inline) 的層疊樣式表 (CSS) 也被高亮。

有多種 html 預處理器語言，html.vim 的編寫方式使得包含它非常容易。要想這麼做，
只要在相應語言的語法高亮文件里加入如下兩行 (該例子來自 asp.vim 文件) 就可以了:

    runtime! syntax/html.vim
    syn cluster htmlPreproc add=asp

現在你只需要把所有包含預處理語言的區域項目加到 htmlPreproc 簇裏就可以了。


HTML/OS (Aestiva 提供)				*htmlos.vim* *ft-htmlos-syntax*

HTML/OS 的色彩高亮方案工作方式如下:

缺省爲函數和變量名使用相同的顏色，因爲 VIM 並不爲 Function 和 Identifier 指定
不同的顏色。要改變這一點 (如果你希望函數名能用不同的顏色加以識別的話，建議使
用)，你需要在 ~/.vimrc 里加入下行: >
  :hi Function term=underline cterm=bold ctermfg=LightGray

當然如果你願意，ctermfg 可以使用別的顏色。

HTML/OS 碰到的另一個問題是沒有特殊的指示 HTML/OS 編碼的文件類型。打開文件並用
下面的方法打開 HTML/OS 語法，你就可以改變這一點: >
  :set syntax=htmlos

最後要提醒一下，啓動 HTML/OS 代碼塊的打開和關閉字符序列分別是 << 或 [[ 和 >>
或 ]]。


IA64				*ia64.vim* *intel-itanium* *ft-ia64-syntax*

爲 Intel Itanium 64 彙編語言提供高亮。|asm.vim| 說明如何識別該文件類型。

要識別 *.inc 文件爲 IA64，在你的 .vimrc 文件里加入這行: >
	:let g:filetype_inc = "ia64"


INFORM						*inform.vim* *ft-inform-syntax*

Inform 高亮包含 Inform 庫提供的符號，因爲多數程序大量使用它們。如果不希望高亮
這些庫裏的符號，在你的 vim 啓動文件里加入: >
	:let inform_highlight_simple=1

缺省假定 Inform 程序面向 Z 機器。並適當地高亮 Z 機器的彙編語言符號。如果期望程
序面向 Glulx/Glk 環境，你需要在啓動文件的序列中加入: >
	:let inform_highlight_glulx=1

這樣就只高亮 Glulx 操作碼，並把 glk() 加到高亮的系統函數集合裏。

Inform 編譯器遇到特定已廢棄的關鍵字時，會標記它們爲錯誤。通常，Vim 也把這些關
鍵字標爲錯誤。如果不想高亮這些錯誤，你必須在啓動文件的序列中加入: >
	:let inform_suppress_obsolete=1

缺省的高亮設置符合編譯器版本 6.30 和庫版本 6.11 的語言特性。如果你使用較老的
Inform 開發環境，可能需要在啓動文件的序列中加入: >
	:let inform_highlight_old=1

IDL							*idl.vim* *idl-syntax*

IDL (Interface Definition Language，接口定義語言) 文件用於定義 RFC 調用。
Microsoft 的領地裏也用來定義 COM 接口和調用。

IDL 的結構足夠簡單，所以可以分析完整語法，而不需要一些啓發式的猜測。結果很大，
甚至可能有些重復工作，但看來能用了。

這裏有一些 Microsft 的 idl 文件擴展。有些可以通過 idl_no_ms_extensions 關閉。

更複雜的擴展可以通過定義 idl_no_extensions 來關閉。

變量				效果 ~

idl_no_ms_extensions		關閉一些 Microsoft 專用的擴展
idl_no_extensions		關閉複雜擴展
idlsyntax_showerror		顯示 IDL 錯誤 (可能過於侵略性，但很有用)
idlsyntax_showerror_soft	使缺省的錯誤顏色柔和一些


JAVA						*java.vim* *ft-java-syntax*

java.vim 語法高亮文件提供若干選項:

在 Java 1.0.2 裏，小括號裏不可能有大括號，所以這被標識爲錯誤。但從 Java 1.1 開
始，這是合法的 (無名類的使用)，因而它不再標爲錯誤。如果你喜歡舊的方式，在 vim
啓動文件里加入下行: >
	:let java_mark_braces_in_parens_as_errors=1

所有 java.lang.* 的標識符在所有的類裏都是可見的。要高亮它們，可用: >
	:let java_highlight_java_lang_ids=1

如果你從 http://www.fleiner.com/vim/download.html 下載 javaid.vim 腳本，你也可
以高亮大多數標準 java 包裏的標識符。
如果你只想高亮特定包裏的標識符，比如說 java.io，可以用: >
	:let java_highlight_java_io=1
察看 javaid.vim 文件，可以得到它支持的所有包的列表。

函數名不會高亮，因爲找到函數的方法取決於你如何寫 Java 代碼。語法文件知道兩種可
以高亮函數的方法:

如果你的函數定義總是使用一個製表、8 個空格或者 2 個空格的縮進，可以設置 >
	:let java_highlight_functions="indent"
不過，如果你遵循 Java 指南里函數和類的命名規則 (關於大小寫)，就可以用 >
	:let java_highlight_functions="style"
如果兩個選項都不合適，但你仍然期望高亮函數聲明，修改 java.vim 裏的定義或者創建
你自己的 java.vim。你自己的版本應該包含原來的版本，並增加高亮函數的代碼。

Java 1.1 裏，只應該用函數 System.out.println() 和 System.err.println() 來進行
調試。所以你可以用不同的方式高亮調試語句。要這麼做，你必須在啓動文件里加上以下
定義: >
	:let java_highlight_debug=1
結果那些語句會被高亮爲 'Special' 字符序列。如果你喜歡用不同的方式分別高亮，必
須爲以下各組定義新的高亮:
    Debug、DebugSpecial、DebugString、DebugBoolean、DebugType
它們分別用來高亮語句本身，調試字符串裏的特殊字符、字符串、布爾常量和類型
(this，super)。我本人喜歡給語句設置別的背景。

Javadoc 是一個程序，它接受特殊的 Java 程序文件裏的註釋，並創建 HTML 頁面。標準
的配置會以類似於 HTML 文件 (見 |html.vim|) 方式高亮該 HTML 代碼，你甚至可以在
代碼里加入 Javascript 和 CSS (見下)。但有四處不同:
  1. 標題 (第一個後面有若干空白跟隨的 '.' 或第一個 '@' 之前的所有字符) 使用不
     同的顏色 (要改變其顏色，修改 CommentTitle 組)。
  2. 文本使用 'Comment' 高亮。
  3. HTML 註釋使用 'Special' 高亮。
  4. 特殊的 Javadoc 標籤 (@see、@param、...) 用 Special 高亮。 而 ( @see、
     @param、@exception 的)參數則使用 Function 高亮。
要關閉該特性，在你的啓動文件里加入該行: >
	:let java_ignore_javadoc=1

如果你使用上述的特殊 Javadoc 註釋高亮方式，你也可以打開 Javascript、Visual
Basic 腳本和內嵌 CSS (樣式表) 的特殊高亮。只有在你實際有包含 Javascript 或內
嵌 CSS 的 Javadoc 註釋時，這纔有意義。要使用的選項分別是 >
	:let java_javascript=1
	:let java_css=1
	:let java_vb=1

要以不同的顏色高亮嵌套的括號，分別定義 javaParen、javaParen1 和 javaParen2 的
顏色。比如用 >
	:hi link javaParen Comment
或 >
	:hi javaParen ctermfg=blue guifg=#0000ff

如果你注意到往回滾動時，高亮出現問題，但 CTRL-L 重畫又可以修正的話，嘗試設置
"java_minlines" 內部變量爲較大的值: >
	:let java_minlines = 50
這使得語法同步在第一個顯示行之前的 50 行開始。缺省值爲 10。使用較大的值的缺點
是重畫會變慢。


LACE						*lace.vim* *ft-lace-syntax*

Lace (Language for Assembly of Classes in Eiffel，Eiffel 類整合語言) 對大小寫
不敏感，但風格指南不是這麼建議的。如果你喜歡對大小寫不敏感的高亮，在啓動文件裏
定義 vim 變量 'lace_case_insensitive': >
	:let lace_case_insensitive=1


LEX						*lex.vim* *ft-lex-syntax*

Lex 使用強力攻擊 (brute-force) 的方式進行同步，因爲 "^%%$" 段定界符沒有提供任
何關於後續段的提示。因而，如果用戶有同步問題的話 (比如使用很大的 lex 文件)，
他/她可以嘗試改變  >
	:syn sync minlines=300
的值。


LIFELINES				*lifelines.vim* *ft-lifelines-syntax*

要把廢棄函數高亮爲錯誤，在 .vimrc 中加入: >

	:let g:lifelines_deprecated = 1
<

LISP						*lisp.vim* *ft-lisp-syntax*

Lisp 語法高亮提供兩個選項: >

	g:lisp_instring : 如果存在，那麼 "(...)" 字符串會被高亮，就像字符串裏
			  的內容是 Lisp 代碼一樣。對 AutoLisp 有用。
	g:lisp_rainbow  : 如果存在且非零，那麼不同的括號層次產生不同的高亮。
<
g:lisp_rainbow 選項爲小括號和反引號提供 10 層不同的色彩。因爲色彩層次的數量關
系，不同於非 rainbow (彩虹) 方式，rainbow 模式直接使用 ctermfg 和 guifg 指定高
亮色彩，而回避了標準的使用高亮組的色彩方案控制。實際使用的高亮值仍然取決於深/
淺設置 (見 |'bg'|)。


LITE						*lite.vim* *ft-lite-syntax*

lite 語法高亮有兩個選項。

如果你喜歡字符串裏的 SQL 語法高亮，使用: >

	:let lite_sql_query = 1

同步的缺省 minlines 爲 100。如果你喜歡別的值，可以把 "lite_minlines" 設爲你想
要的值。例如: >

	:let lite_minlines = 200


LPC						*lpc.vim* *ft-lpc-syntax*

LPC 代表一種簡單又節省內存的語言: Lars Pensj| C。LPC 的文件名通常是 *.c。把這
些文件識別爲 LPC 會惹惱那些只用 C 程序的用戶。如果你想使用 Vim 的 LPC 語法，在
你的 .vimrc 文件裏設置變量: >

	:let lpc_syntax_for_c = 1

如果這對某些特殊的 C 或 LPC 文件不能工作，用模式行。在 LPC 文件裏:

	// vim:set ft=lpc:

對於被識別爲 LPC 的 C 文件:

	// vim:set ft=c:

如果你不想設置此變量，在_每個_ LPC 文件裏使用模式行。

LPC 有若干實現，我們打算支持最常用的實現。這裏缺省的 LPC 語法基於 MudOS 系列。
對於 MudOS v22 和以前的版本。你應該關閉合適的修飾符，它也會把 v22 之後的新的
efun 認定爲非法。如果你使用最新的 MudOS 版本，不要設置該變量: >

	:let lpc_pre_v22 = 1

對於 LpMud 3.2 系列的 LPC: >

	:let lpc_compat_32 = 1

對於 LPC4 系列的 LPC: >

	:let lpc_use_lpc4_syntax = 1

對於 uLPC 系列的 LPC:
uLPC 是爲 Pike 開發的，所以你應該使用 Pike 的語法，而且源文件應該是 *.pike。


LUA						*lua.vim* *ft-lua-syntax*

Lua 語法文件可用於 Lua 4.0、5.0、5.1 或 5.2 (5.2 是缺省)。用全局變量
lua_version 和 lua_subversion 可以選擇其中一個版本。例如，如果要激活 Lua 5.1
高亮，設置變量如下: >

	:let lua_version = 5
	:let lua_subversion = 1


MAIL						*mail.vim* *ft-mail.vim*

Vim 高亮 email 的所有標準元素 (信頭、簽名、引用文本和 URL / email 地址)。要符
合標準的習慣，簽名應該以 "--" 開頭，跟隨可選的若干空格並以回車結束的一行開始。

Vim 把 ']'、'}'、'|'、'>' 或者有 '>' 跟隨的單詞開始的行高亮爲引用文本。不過，
只有在引用文本用 '>' 的方式引用 (後面可跟一個可選的空格)，Vim 才把把該文本里的
信頭和簽名高亮爲引用文本。

mail.vim 缺省從第一個顯示行之前的 100 行開始同步語法。如果你的機器很慢，而且通
常處理的 email 的信頭不長，你可以把它設爲較小的值: >

    :let mail_minlines = 30


MAKE						*make.vim* *ft-make-syntax*

Makefile 裏，命令通常被高亮以便你發現錯誤。不過，如果你覺得顏色太多了，可以這
樣關閉此特性: >

	:let make_no_commands = 1


MAPLE						*maple.vim* *ft-maple-syntax*

Waterloo Maple Inc 的 Maple V 支持符號代數。該語言支持很多函數包，用戶可以選擇
性地裝載。如果用戶願意，可以高亮 Maple V release 4 提供的標準包函數。用戶可以
在 .vimrc 文件里加入: >

	:let mvpkg_all= 1

來高亮所有的包裏的函數。用戶也可以通過從下表選擇變量/包來挑選一個子集，並在
.vimrc 文件裏 (在執行 $VIMRUNTIME/syntax/syntaxvim 之前) 設置挑選的變量爲 1 就
可以了。

			Maple V 包函數選擇器表 >
  mv_DEtools	 mv_genfunc	mv_networks	mv_process
  mv_Galois	 mv_geometry	mv_numapprox	mv_simplex
  mv_GaussInt	 mv_grobner	mv_numtheory	mv_stats
  mv_LREtools	 mv_group	mv_orthopoly	mv_student
  mv_combinat	 mv_inttrans	mv_padic	mv_sumtools
  mv_combstruct	 mv_liesymm	mv_plots	mv_tensor
  mv_difforms	 mv_linalg	mv_plottools	mv_totorder
  mv_finance	 mv_logic	mv_powseries


MATHEMATICA		*mma.vim* *ft-mma-syntax* *ft-mathematica-syntax*

自動假設空白的 *.m 文件爲 Matlab 文件，除非你在 .vimrc 裏指定了: >

	let filetype_m = "mma"


MOO						*moo.vim* *ft-moo-syntax*

如果你在表達式裏使用 C 風格的註釋但發現它影響了高亮，可以嘗試使用擴展的 (會變
慢！) C 風格註釋的匹配: >

	:let moo_extended_cstyle_comments = 1

要關閉字符串裏的代詞替換 (pronoun substitution) 模式高亮: >

	:let moo_no_pronoun_sub = 1

要關閉正規表達式 '%|' 操作符和字符串裏匹配的 '%(' 和 '%)' 所用的高亮: >

	:let moo_no_regexp = 1

可以識別不匹配的雙引號並高亮爲錯誤: >

	:let moo_unmatched_quotes = 1

要高亮內建的屬性 (.name、.location、.programmer 等): >

	:let moo_builtin_properties = 1

可以識別未知的內建函數並高亮爲錯誤。如果你使用該選項，應該把自己的擴展加到
mooKnownBuiltinFunction 組裏。要打開該選項: >

	:let moo_unknown_builtin_functions = 1

把 sprintf() 加到已知內建函數列表的例子: >

	:syn keyword mooKnownBuiltinFunction sprintf contained


MSQL						*msql.vim* *ft-msql-syntax*

msql 語法高亮有兩個選項。

如過你希望高亮字符串裏的 SQL 語法，使用: >

	:let msql_sql_query = 1

同步的 minlines 缺省爲 100。如果你喜歡別的值，可以設置 "msql_minlines" 爲你所
希望的值。例如: >

	:let msql_minlines = 200


NCF						*ncf.vim* *ft-ncf-syntax*

NCF 語法高亮有一個選項。

如果你想把不能識別的 (依據 ncf.vim) 語句高亮爲錯誤，使用: >

	:let ncf_highlight_unknowns = 1

如果你不想高亮它們爲錯誤，留着該變量不設置就可以了。


NROFF						*nroff.vim* *ft-nroff-syntax*

nroff 語法文件可直接用於 AT&T n/troff 而無需修改。如果要使用 GNU groff，你需要
在使用之前激活語法文件裏的一些附加特性。

例如，Linux 和 BSD 的發佈版本使用 groff 作爲缺省的文本處理包。要激活 groff
附加的語法高亮特性，在你的啓動文件里加入以下選項: >

  :let b:nroff_is_groff = 1

Groff 和老的 AT&T n/troff 不同，後者還可以在 Solaris 找到。Groff 宏和請求名可
以超過 2 個字符，而且有語言基本命令之外的擴展。例如，AT&T troff 裏你可以用請求
\(yr 得到 2 位數的年份。groff 裏爲了照顧兼容性，可以使用相同的請求，你也可以直
接使用 groff 本身的宏: \[year]。宏請求可以超過 2 個字符，比如，GNU mm 接受
".VERBON" 和 ".VERBOFF" 請求，以創建 verbatim (不作轉換的) 環境。

要得到 g/troff 能給出的最好的輸出，需要遵循一些關於空格和標點的簡單的規則。

1. 不要在行尾留空白。

2. 在句尾的句號、感歎號等之後留且只留一個空格。

3. 由於下面的原因，最好在所有的句號之後立即回車。

這些不尋常的提示的背後原因是，如果你不遵循上面的這些規則，g/n/troff 使用的換行
算法很容易弄錯。

和 TeX 不同，troff 逐行而不是逐段填充文本。此外，它沒有 glue (可伸縮的距離) 或
stretch 的概念，所有的水平和垂直空白輸入都直接成爲輸出。

因此你必須小心，不要在句子之間留下比你在最終文檔想要的更多的空白。因此，通常在
每個標點符號之後都立即插入一個回車。如果你想要最終處理過的文本 "對齊"，需要在
輸入文本里維持常規的空間。要把行尾的空格和標點之後兩個或更多的空格標爲錯誤，可
用: >

  :let nroff_space_errors = 1

另一個檢測額外的空格和其它錯誤的技術會影響你文件的正確排版。這個方法是在你的配
置文件裏定義語法組 "nroffDefinition" 和 "nroffDefSpecial" 顯眼的高亮定義。例
如: >

  hi def nroffDefinition term=italic cterm=italic gui=reverse
  hi def nroffDefSpecial term=italic,bold cterm=italic,bold
			 \ gui=reverse,bold

如果你想像段標記符那樣方便地瀏覽源文件裏的預處理項目，可以在 .vimrc 文件裏激活
以下選項: >

	let b:preprocs_as_sections = 1

還有，語法文件爲 ms 包裏設置帶縮進的 (exdented) 段落宏 (.XP) 增加了一個附加的
段標記符。

最後，有一個 |groff.vim| 語法文件，可以基於每個文件或，缺省情況下，在全局打開
groff 的語法高亮。


OCAML						*ocaml.vim* *ft-ocaml-syntax*

OCaml 語法文件處理帶以下後綴的文件: .ml、.mli、.mll 和 .mly。設置以下變量 >

	:let ocaml_revised = 1

你就可以切換標準的 OCaml 語法爲 camlp4 預處理器支持的改進的語法。設置變量 >

	:let ocaml_noend_error = 1

防止把 "end" 高亮爲錯誤，這可用於源程序包含很長的結構而 Vim 不再能保持同步的場
合。


PAPP						*papp.vim* *ft-papp-syntax*

PApp 語法文件處理 .papp 文件和，在一定程度上，.pxml 和 .pxsl 文件。它們都是
perl / xml / html / 其它格式 的混合，並使用 xml 作爲頂層的文件格式。缺省，所有
phtml 和 pxml 段裏的內容都被處理爲包含內嵌預處理器命令的字符串。如果你在啓動文
件裏設置變量: >

	:let papp_include_html=1

它就會試圖語法高亮 pthml 段裏的 html 代碼，但這相對較慢，而且對於有效的編輯未
免色彩太鮮豔了些 ;)

可以在 http://papp.plan9.de 找到最新的 papp.vim 語法文件的版本。


PASCAL						*pascal.vim* *ft-pascal-syntax*

匹配 "*.p" 的文件可以是 Progress 或者 Pascal 的。如果自動檢測對你不適用，或者
你從來不編輯 Progress，在啓動 vimrc 里加入: >

   :let filetype_p = "pascal"

Pascal 語法文件被擴展，以支持 Turbo Pascal、Free Pascal 編譯器和 GNU Pascal 編
譯器的一些擴展。也支持 Delphi 的關鍵字。缺省打開 Turbo Pascal 7.0 特性。如果你
只想使用標準的 Pascal 關鍵字，在你的啓動文件里加入下行: >

   :let pascal_traditional=1

要打開 Delphi 專用的構造 (比如單行註釋、關鍵字、等等): >

   :let pascal_delphi=1


pascal_symbol_operator 選項控制符號 (symbol) 操作符，如 +、* 等，是否使用
Operator 的色彩高亮。要給符號的操作符加上顏色，在你的啓動文件里加入下行: >

   :let pascal_symbol_operator=1

有些函數缺省是高亮的。要關閉: >

   :let pascal_no_functions=1

另外，一些編譯器有專門的變量。除了 pascal_delphi 以外，還有 pascal_gpc 和
pascal_fpc。缺省試圖匹配 Turbo Pascal 的擴展。 >

   :let pascal_gpc=1

或 >

   :let pascal_fpc=1

要確保字符串在一行內定義，你可以定義 pascal_one_line_string 變量。 >

   :let pascal_one_line_string=1

如果你不喜歡 <Tab> 字符，你可以設置 pascal_no_tabs 變量。製表會被高亮爲
Error。 >

   :let pascal_no_tabs=1



PERL						*perl.vim* *ft-perl-syntax*

perl 的語法高亮有一些可用的選項。

現在缺省打開內建 POD 的高亮。如果不希望因 Perl 文件內嵌的 POD 高亮增加複雜度，
可以把 'perl_include_pod'  選項設爲 0: >

	:let perl_include_pod = 0

要減低分析的複雜度 (同時提高了效率)，你可以關閉變量名和內容的分析過程的兩個元
素。

要使變量和函數名裏對包的引用與名字的其它部分不區別顯示 (如 '$PkgName::VarName'
裏的 'PkgName::'): >

	:let perl_no_scope_in_variables = 1

(Vim 6.x 裏相反，用 "perl_want_scope_in_variables" 打開區別顯示。)

如果你不想分析複雜的結構，比如 '@{${"foo"}}': >

	:let perl_no_extended_vars = 1

(Vim 6.x 裏相反，用 "perl_extended_vars" 打開此項分析。)

你可以改變顏色字符串。缺省，字符串和 qq 等變形會象下面第一行那樣高亮。如果你設
置了變量 perl_string_as_statement，那麼就像下面第二行那樣高亮。
   "hello world!"; qq|hello world|;
   ^^^^^^^^^^^^^^NN^^^^^^^^^^^^^^^N	  (unlet perl_string_as_statement)
   S^^^^^^^^^^^^SNNSSS^^^^^^^^^^^SN	  (let perl_string_as_statement)

(^ = perlString、S = perlStatement、N = 什麼都沒有)

同步有三個選項。前兩個關掉一些激活同步的方法，而只有在無法正確工作的時候你才需
要它們。比如，如果滾動時突然全屏的顏色發生改變，那麼你應該嘗試改變並關閉其中的
某一個。如果你可以發現哪一行導致這種錯誤，請告訴我。

大致上，其中一個在 "^\s*sub\s*" 上激活，另一個則在 "^[$@%]" 上。 >

	:let perl_no_sync_on_sub
	:let perl_no_sync_on_global_var

下面，你還可以設置 VIM 往前找語法高亮的起始點的最大距離。 >

	:let perl_sync_dist = 100

如果你想要在 perl 裏使用摺疊，設置 perl_fold: >

	:let perl_fold = 1

如果你想摺疊 if 等語句塊，設置如下: >

	:let perl_fold_blocks = 1

'perl_fold' 置位時，缺省摺疊例程。如果不想要，可以設置
'perl_nofold_subs': >

	:let perl_nofold_subs = 1

缺省不摺疊無名例程；可以用 'perl_fold_anonymous_subs' 打開之: >

	:let perl_fold_anonymous_subs = 1

'perl_fold' 置位時，缺省對包摺疊。如果不想要，可以設置
'perl_nofold_packages': >

	:let perl_nofold_packages = 1

PHP3 和 PHP4		*php.vim* *php3.vim* *ft-php-syntax* *ft-php3-syntax*

[注意: 以前這被稱爲 "php3"，但因爲現在這也支持 php4，它被改名爲 "php"]

php 的語法高亮支持以下選項。

如果你喜歡字符串裏的 SQL 語法高亮: >

  let php_sql_query = 1

要高亮 Baselib 方法: >

  let php_baselib = 1

打開字符串裏的 HTML 語法高亮: >

  let php_htmlInStrings = 1

使用舊的色彩風格: >

  let php_oldStyle = 1

打開 ASP 風格的短標籤的高亮: >

  let php_asp_tags = 1

關閉短標籤: >

  let php_noShortTags = 1

要高亮外層 ] 或 ) 的錯誤: >

  let php_parent_error_close = 1

要在有打開的 ( 和 [ 但沒有相應的結束符號的情況下跳過 php 結束標籤: >

  let php_parent_error_open = 1

打開類和函數的摺疊: >

  let php_folding = 1

選擇同步方法: >

  let php_sync_method = x

x = -1 使得同步以搜索方法進行 (缺省)，
x > 0 使得同步至少往回 x 行，
x = 0 使得同步從頭開始。


PLAINTEX				*plaintex.vim* *ft-plaintex-syntax*

TeX 是排版語言，而 plaintex 是代表 Tex 的 "平凡" 變種的文件類型。如果你想
*.tex 文件被識別爲平凡 TeX，見 |ft-tex-plugin|。

此語法文件有以下選項 >

	let g:plaintex_delimiters = 1

如果你想高亮方括號 "[]" 和大括號 "{}" 的話。


PPWIZARD					*ppwiz.vim* *ft-ppwiz-syntax*

PPWizard 是 HTML 和 OS/2 INF 文件的預處理器。

該語法文件有如下選項:

- ppwiz_highlight_defs : 決定 PPWizard 定義的高亮模式。可能值是

  ppwiz_highlight_defs = 1 : PPWizard #define 語句保留其內容的色彩 (比如，
    PPWizard 的宏和變量)

  ppwiz_highlight_defs = 2 : 預處理器 #define 和 #evaluate 語句使用單色顯示，
    除了續行符以外

  缺省 ppwiz_highlight_defs 的設置爲 1。

- ppwiz_with_html : 如果該值爲 1 (缺省)，高亮按本義出現的 HTML 代碼；如果爲
  0，把 HTML 代碼當成普通的文本。


PHTML						*phtml.vim* *ft-phtml-syntax*

phtml 語法高亮有兩個選項。

如果你喜歡字符串裏的 SQL 語法高亮，使用: >

	:let phtml_sql_query = 1

同步的 minlines 缺省爲 100。如果你喜歡別的值，可以設置 "phtml_minlines" 爲你所
希望的值。例如: >

	:let phtml_minlines = 200


POSTSCRIPT				*postscr.vim* *ft-postscr-syntax*

PostScript 的高亮有若干選項。

首先決定是 PostScript 語言的哪個版本要高亮。目前定義了三個語言版本。Level 1 是
原始和基礎的版本，包括所有的 Level 2 發佈之前的擴展。Level 2 是最常用的版本，
包括 Level 3 發佈之前它自身的所有擴展。Level 3 是目前支持的最高版本。你可以
這樣定義 postscr_level 變量，以選擇需要高亮的 PostScript 的語言級別: >

	:let postscr_level=2

如果該變量沒有定義，缺省值爲 2 (Level 2)，因爲這是目前最常用的版本。

注意，不是所有的 PS 解釋器都支持某一特定語言級別的所有語言特性。特別是，PS 文
件開頭的 %!PS-Adobe-3.0 並_不_意味着使用的 PostScript 是 Level 3 的
PostScript！

如果你使用 Display PostScript，可以這樣定義 postscr_display 變量來包含 Display
PS 語言特性的高亮: >

	:let postscr_display=1

如果你使用 Ghostscript，可以這樣定義 postscr_ghostscript 變量來包含
Ghostscript 特有的語言特性的高亮: >

	:let postscr_ghostscript=1

PostScript 是一個很大的語言，有許多預定義的元素。儘管包含所有這些元素的高亮很
有用，在較慢的機器上這會使得 Vim 變慢。爲了使得對機器更友善，缺省不給字體名和
字符編碼高亮。如果你不是顯式地打開它們，應該沒有問題。如果你確實想看到它們的高
亮，可以設置下面之中的一個或兩個變量: >

	:let postscr_fonts=1
	:let postscr_encodings=1

關於 and、or 和 not 的高亮有一個風格的選項。PostScript 裏，這些操作符的函數取
決於它們操作數的類型 - 如果操作數都是布爾型，它們是邏輯操作符。如果是整數，它
們是二進制操作符。如果二進制和布爾型操作符高亮方式不同，它們可以用任何一種方式
高亮。缺省它們被作爲邏輯操作符。如果這樣定義 postscr_andornot_binary 變量，它
們可以用二進制操作符方式進行高亮: >

	:let postscr_andornot_binary=1
<

			*ptcap.vim* *ft-printcap-syntax*
PRINTCAP + TERMCAP	*ft-ptcap-syntax* *ft-termcap-syntax*

該語法文件適用於 printcap 和 termcap 數據庫。

要使得 Vim 識別不匹配模式 "printcap" 或 "termcap" 的 printcap/termcap 文件，你
需要在 |myfiletypefile| 文件裏定義合適你的系統的附加的模式。對這些模式，你必須
設置變量 "b:ptcap_type" 爲 "print" 或 "term"，然後設置 'filetype' 選項爲
ptcap。

比如，要使得 Vim 識別 /etc/termcaps/ 裏的所有文件爲 termcap 文件，加入下行: >

   :au BufNewFile,BufRead /etc/termcaps/* let b:ptcap_type = "term" |
				       \ set filetype=ptcap

如果你注意到往回滾動時高亮有問題，但 CTRL-L 又可以修正的時候，嘗試設置
"ptcap_minlines" 內部變量爲一個大的數字: >

   :let ptcap_minlines = 50

(缺省爲 20 行。)


PROGRESS				*progress.vim* *ft-progress-syntax*

匹配 "*.w" 的文件可以是 Progress 或者 cweb 的。如果自動識別對你無效，或者你從
來不編輯 cweb，在你的啓動 vimrc 里加入: >
   :let filetype_w = "progress"
這同樣適用於可爲彙編文件的 "*.i" 和可爲 Pascal 文件的 "*.p"。如果你不使用彙編
和 Pascal，你可以這麼用: >
   :let filetype_i = "progress"
   :let filetype_p = "progress"


PYTHON						*python.vim* *ft-python-syntax*

有六個選項可以控制 Python 的語法高亮。

關於高亮數值: >
	:let python_no_number_highlight = 1

關於高亮內建函數: >
	:let python_no_builtin_highlight = 1

關於高亮標準例外: >
	:let python_no_exception_highlight = 1

關於高亮 doctest 和其中的代碼: >
	:let python_no_doctest_highlight = 1
或 >
	:let python_no_doctest_code_highlight = 1
(第一個選項隱含第二個)。

要高亮行尾的空白還有空格和製表的混合: >
	:let python_space_error_highlight = 1

如果你想要所有可能的 Python 高亮 (等同於置位上面最後的選項及復位其餘選項): >
	:let python_highlight_all = 1

注意: 對以上選項，只關心其存在於否，值並不重要，可以把上面的 1 換成任何值。


QUAKE						*quake.vim* *ft-quake-syntax*

Quake 語法定義應可用於多數基於某個 Quake 引擎的 FPS (First Person Shooter)。不
過，在相關的三個遊戲 (Quake、Quake 2 和 Quake 3 Arena) 中，命令的名字略有不
同。所以，語法定義檢查三個全局變量是否存在，從而使用戶可以指定他們的文件裏哪些
命令是合法的。這三個變量的設置有如下效果。

設置使得高亮命令只適用於 Quake: >
	:let quake_is_quake1 = 1

設置使得高亮命令只適用於 Quake 2: >
	:let quake_is_quake2 = 1

設置使得高亮命令只適用於 Quake 3 Arena: >
	:let quake_is_quake3 = 1

組合這三個變量的使用也是可以的，不過高亮的命令也許比你的遊戲裏實際可用的命令要
多。


READLINE				*readline.vim* *ft-readline-syntax*

readline 庫主要由 BASH 外殼使用，在已有的命令和選項的基礎上，它又增加了不少。
要高亮這些附加的命令和選項，可以把這行加到你的 |vimrc| 裏，或者在載入使用
readline 語法的文件前，在命令行輸入: >
	let readline_has_bash = 1

這使得 BASH (2.05a 和其後的版本，也包括部分以前的) 增加的命令被高亮。


RESTRUCTURED TEXT			*rst.vim* *ft-rst-syntax*

可以這樣設置代碼塊使用的語法定義
	let rst_syntax_code_list = ['vim', 'lisp', ...]


REXX						*rexx.vim* *ft-rexx-syntax*

如果你注意到往回滾動時，高亮出現問題，但 CTRL-L 重畫又可以修正的話，嘗試設置
"rexx_minlines" 內部變量爲較大的值: >
	:let rexx_minlines = 50
這使得語法同步在第一個顯示行之前的 50 行開始。缺省值爲 10。使用較大的值的缺點
是重畫會變慢。

Vim 試圖自己猜測 ".r" 文件的真實類型。如果無法檢測 (根據註釋行內容)，假定爲
"r"。要使缺省爲 rexx，給 .vimrc 文件加上:  *g:filetype_r*
>
	:let g:filetype_r = "r"


RUBY						*ruby.vim* *ft-ruby-syntax*

Ruby 語法高亮有若干選項。

缺省，"end" 關鍵字根據它關閉的塊對應的打開語句設定顏色。儘管很有用，該特性很消
耗資源: 如果你發現重畫變慢 (或者你所在的終端色彩支持不好)，你可能想關閉該特
性，只要定義 "ruby_no_expensive" 變量即可: >

	:let ruby_no_expensive = 1
<
此時，所有的控制關鍵字使用相同的顏色。

如果你想使用該特性，但注意到往回滾動時，高亮出現問題，但 CTRL-L 重畫又可以修正
的話，嘗試設置 "ruby_minlines" 變量超過 50: >

	:let ruby_minlines = 100
<
理想的話，該值應該足夠大，使得最大的類或模塊能夠得到處理。

特殊標識符的高亮可以通過刪除 rubyIdentifier 高亮來關閉: >

	:hi link rubyIdentifier NONE
<
這會防止標識符 "ConstantName" (常數)、"$global_var" (全局變量)、"@@class_var"
(類變量)、"@instance_var" (實例變量)、"| block_param |" (塊參數)、和 ":symbol"
(符號) 的特殊高亮。

Kernel、Module 和 Object 裏的主要方法缺省都是高亮的。可以通過定義
"ruby_no_special_methods" 關閉之: >

	:let ruby_no_special_methods = 1
<
這會禁止重要方法的高亮，比如 "require"、"attr"、"private"、"raise" 和 "proc"。

可以高亮 Ruby 操作符。可通過定義 "ruby_operators" 來打開: >

	:let ruby_operators = 1
<
可以通過定義 "ruby_space_errors" 打開空白錯誤的高亮: >

	:let ruby_space_errors = 1
<
會高亮行尾的空白，而空格後的製表也被認爲是錯誤。通過定義
"ruby_no_trail_space_error" 和 "ruby_no_tab_space_error"，可以進一步限定。這兩
個變量分別忽略行尾空白和空格之後的製表。

定義 "ruby_fold" 可以打開摺疊: >

	:let ruby_fold = 1
<
會把 'foldmethod' 選項設爲 "syntax"，並且提供了類、模塊、方法、代碼塊、here 文
檔和註釋的摺疊。

多行註釋的摺疊可以通過定義 "ruby_no_comment_fold" 來關閉: >

	:let ruby_no_comment_fold = 1
<

SCHEME						*scheme.vim* *ft-scheme-syntax*

缺省只高亮 R5RS 關鍵字並進行適當的縮進。

如果定義  b:is_mzscheme 或 g:is_mzscheme 變量，可以使用 MzScheme 特定的內容。

此外，scheme.vim 也支持 Chicken Scheme->C compiler 的關鍵字。如果需要，定義
b:is_chicken 或 g:is_chicken。


SDL						*sdl.vim* *ft-sdl-syntax*

SDL 的高亮可能會缺少一些關鍵字，但 SDL 的關鍵字太多了，完全照顧過來是不太可能
的。

新的標準 SDL-2000 指定所有的標識符都是大小寫敏感的 (以前並非如此)，而所有使用
的關鍵字必須或者是完全小寫，或者完全大寫。要使得高亮能夠反映這些特性，你可以設
置如下的變量: >
	:let sdl_2000=1

這也會設置很多新的關鍵字。如果你想屏蔽舊的關鍵字 (其實，這是個好主意)，可以
用: >
	:let SDL_no_96=1

縮進可能還沒完全處理好，不過我在自己的項目目前的應用裏已經相當滿意了。


SED						*sed.vim* *ft-sed-syntax*

要使得製表在普通的空白裏突出顯示 (方法是在製表上使用 Todo 高亮)，在 vimrc 文件
裏如此定義 "highlight_sedtabs" >

	:let highlight_sedtabs = 1

(這種特殊高亮只適用於搜索模式、替換文本、地址或者 Append/Change/Insert
命令裏包含的文本中的製表。) 如果你打開該選項，那麼最好把製表寬度設爲一個字符；
這麼做，你很容易計算字符串裏的製表數量。

漏洞:

  transform 命令 (y) 和 substitute 命令的處理相同。也就是說，就語法文件而言，
  transform 和 substitute 接受相同的標誌。這不正確 (Transform 不接受標誌)。但
  我容忍這個問題，因爲牽涉的命令需要很複雜的處理 (95 個模式，每個可能的模式定
  界符就需要一個模式)。


SGML						*sgml.vim* *ft-sgml-syntax*

SGML 文件裏，標籤的色彩方案工作方式如下。

開放標籤的 <> 和關閉標籤的 </> 的色彩不同。這是有意的。開放標籤使用 'Function'
色彩，而關閉標籤使用 'Type' 色彩 (見 syntax.vim 察看它們是怎麼定義的)。

已知的標簽名和 C 語句的色彩相同。未知的標簽名和相應的 <> 或 </> 顏色相同，以便
糾錯。

注意 這也適用於參數 (或屬性) 的名字。已知的屬性名和未知的標色不同。

一些 SGML 標籤用於改變文本的顯示。sgml.vim 語法色彩文件識別以下的標籤，並相應
地改變普通文本的顯示方式: <varname> <emphasis> <command> <function> <literal>
<replaceable> <ulink> 和 <link>。

如果你想改變文本顯示的方式，必須重定義以下的語法組:

    - sgmlBold
    - sgmlBoldItalic
    - sgmlUnderline
    - sgmlItalic
    - sgmlLink 設定鏈接

要使得重定義能夠工作，你必須重定義所有的組。在你的 vimrc (這是根據初始化時讀入
文件的順序) 裏定義下面的變量 >
	:let sgml_my_rendering=1

在你的 vimrc 文件里加上這行，可以屏蔽這種顯示方式: >
	:let sgml_no_rendering=1

(從 Claudio Fleiner <claudio@fleiner.com> 的 html.vim 的幫助文本轉來)


SH		*sh.vim* *ft-sh-syntax* *ft-bash-syntax* *ft-ksh-syntax*

這裏討論 "普通的" Unix 外殼，即 (Bourne) sh、bash 和 Korn shell。
(譯者注: 原文作 Borne Shell。似爲拼寫錯誤，因爲 Steve Bourne 是 sh 的作者)

Vim 試圖根據文件名決定使用的 shell 類型: >

    ksh : .kshrc* *.ksh
    bash: .bashrc* bashrc bash.bashrc .bash_profile* *.bash
<
如果這些都不符，那麼就檢查文件的第一行 (比如 /bin/sh  /bin/ksh	/bin/bash)。如
果第一行指定了外殼類型，那麼就使用該類型。不過有的文件 (比如 .profile) 肯定是
外殼文件，但其類型並不容易推出。另外，有的系統裏 sh 被符號鏈接到 "bash"
(linux、Windows+cygwin) 或 "ksh" (posix)。

你可以在 <.vimrc> 裏設置下列三個變量中的一個，以指定全局的缺省值:

    ksh: >
	let g:is_kornshell = 1
<   posix: (和設置 is_kornshell 爲 1 效果相同) >
	let g:is_posix     = 1
<   bash: >
	let g:is_bash	   = 1
<   sh: (缺省) Bourne shell >
	let g:is_sh	   = 1

如果沒有 "#! ..." 一行，而用戶也沒有用上述方法設定缺省的 sh.vim 語法設置，那麼
syntax/sh.vim 假定使用 Bourne shell 語法。請不要在錯誤報告裏引用 RFC 或者市場
佔有率的統計數據 (譯者注: 此處大概指希望使用其它缺省值的用戶) -- 在 <.vimrc>
文件裏自己選擇系統使用的缺省 sh 版本就可以了。

syntax/sh.vim 文件提供若干級別的基於語法的摺疊: >

	let g:sh_fold_enabled= 0     (缺省，無語法高亮)
	let g:sh_fold_enabled= 1     (打開函數摺疊)
	let g:sh_fold_enabled= 2     (打開 here 文檔摺疊)
	let g:sh_fold_enabled= 4     (打開 if/do/for 摺疊)
>
那麼若干語法項目 (Here 文檔和函數體) 就可以進行語法摺疊 (見 |:syn-fold|)。把這
些值加在一起可以得到多種項目的摺疊: >

	let g:sh_fold_enabled= 3     (打開函數和 here 文檔的摺疊)

如果你注意到往回滾動時，高亮出現問題，但 CTRL-L 重畫又可以修正的話，嘗試設置
"sh_minlines" 內部變量爲較大的值: >
	:let sh_minlines = 500
這使得語法同步在第一個顯示行之前的 500 行開始。缺省值爲 200。使用較大的值的缺
點是重畫會變慢。

如果你沒有要同步的東西，但顯示又很慢，可以設置 "sh_maxlines" 內部變量來加速。
比如: >

	let sh_maxlines = 100
<
缺省值是 sh_minlines 的兩倍。設置爲較小的值可以提高顯示的速度。缺點是高亮錯誤
出現的可能性也較大。

						*g:sh_isk* *g:sh_noisk*
shell 語言看來允許 "." 成爲單詞、命令等的一部分，所以 sh.vim 中 isk 的定義應包
含它。從 syntax/sh.vim v116 版開始，syntax.vim 缺省在 |'iskeyword'| 中加入了
"."。可以控制此一行爲: >
	let g:sh_isk  = '..任何你想加入 iskeyword 的字符'
	let g:sh_noisk= 1  " 反之，如果此變量存在，_不_改變 isk
<
						*sh-embed*  *sh-awk*
 Sh: 內 嵌 語 言~

你也許想要在 sh 裏內嵌其他語言。多謝 Lorance Stinson 提供了一個 awk 的例子。
把下面內容寫入 $HOME/.vim/after/syntax/sh/awkembed.vim: >

    " AWK Embedding: {{{1
    " ==============
    " Shamelessly ripped from aspperl.vim by Aaron Hope.
    if exists("b:current_syntax")
      unlet b:current_syntax
    endif
    syn include @AWKScript syntax/awk.vim
    syn region AWKScriptCode matchgroup=AWKCommand start=+[=\\]\@<!'+ skip=+\\'+ end=+'+ contains=@AWKScript contained
    syn region AWKScriptEmbedded matchgroup=AWKCommand start=+\<awk\>+ skip=+\\$+ end=+[=\\]\@<!'+me=e-1 contains=@shIdList,@shExprList2 nextgroup=AWKScriptCode
    syn cluster shCommandSubList add=AWKScriptEmbedded
    hi def link AWKCommand Type
<
此代碼會接受如下單引號括起的 awk 代碼: >
	awk '...awk code here...'
使之採用 awk 高亮語法。顯然此方法可以類似地擴展到其他語言上。


SPEEDUP						*spup.vim* *ft-spup-syntax*
(AspenTech plant simulator)

Speedup 語法文件有如下選項:

- strict_subsections : 如果定義該變量，只有段 (section) 和子段 (subsection) 裏
  的關鍵字會作爲 Statement 高亮，而其它關鍵字不會 (比如 OPERATION 段裏的
  WITHIN)。

- highlight_types : 該變量的定義使得流類型 (stream type)，比如 temperature 或
  pressure，用 Type 高亮，而不是普通的 Identifier。這裏包括 DECLARE 段常見的類
  型；如果定義了自己的類型，要在語法文件裏自己加入。

- oneline_comments : 該值可選 1 到 3，它決定了 # 風格的註釋的高亮方式。

  oneline_comments = 1 : 允許偶數個 # 之後的正常 Speedup 代碼。

  oneline_comments = 2 : 第二個 # 開始的代碼顯示爲出錯。這是缺省設置。

  oneline_comments = 3 : 如果某行包含超過一個 #，把整行顯示爲出錯。

特別因爲 OPERATION 段因爲 PRESET (預設) 的變量而可能會很大，同步的正確設置很重
要。如果你的機器足夠快，你可以在語法文件的末尾增加 minlines 和/或 maxlines 的
值。


SQL						*sql.vim* *ft-sql-syntax*
				*sqlinformix.vim* *ft-sqlinformix-syntax*
				*sqlanywhere.vim* *ft-sqlanywhere-syntax*

儘管有 ANSI 的 SQL 標準，多數數據庫引擎都增加了自己的擴展。Vim 目前支持 Oracle
和 Informix 的 SQL 方言。Vim 缺省假設 "*.sql" 文件使用 Oracle SQL。

Vim 目前通過不同語法腳本提供不同供應商的 SQL 支持。你可以把 Vim 的缺省設置從
Oracle 改爲任何目前支持的 SQL 類型。你也可以方便地爲每個緩衝區設置不同的 SQL
方言。

詳細的操作可見 |ft_sql.txt|。


TCSH						*tcsh.vim* *ft-tcsh-syntax*

這裏討論名爲 "tcsh" 的外殼。這是 csh 的超集。關於如何檢測文件類型，見
|csh.vim|。

Tcsh 不允許字符串裏的 \"，除非設置了 "backslash_quote" 外殼變量。如果你希望
VIM 認定不應該存在反斜槓 + 引號的構造，在 .vimrc 里加入這行: >

	:let tcsh_backslash_quote = 0

如果你注意到往回滾動時，高亮出現問題，但 CTRL-L 重畫又可以修正的話，嘗試設置
"tcsh_minlines" 內部變量爲較大的值: >
	:let tcsh_minlines = 1000
這使得語法同步在第一個顯示行之前的 1000 行開始。如果設置 "tcsh_minlines" 爲
"fromstart"，同步從文件開始處進行。tcsh_minlines 的缺省值爲 100。使用較大的值
的缺點是重畫會變慢。


TEX				*tex.vim* *ft-tex-syntax* *latex-syntax*

			Tex 內容~
	Tex: 要語法摺疊麼？				|tex-folding|
	Tex: 不想拼寫檢查				|g:tex_nospell|
	Tex: 不想檢查註釋裏的拼寫？			|tex-nospell|
	Tex: 需要在 Verbatim 區中使用拼寫檢查？		|tex-verb|
	Tex: 在註釋還是數學模式裏			|tex-runon|
	Tex: 語法高亮很慢？				|tex-slow|
	Tex: 想高亮更多的命令？				|tex-morecommands|
	Tex: 過多的 Error 高亮？			|tex-error|
	Tex: 需要新的數學模式的組？			|tex-math|
	Tex: 開始新的風格？				|tex-style|
	Tex: 利用隱藏模式				|tex-conceal|
	Tex: 選擇性的隱藏模式				|g:tex_conceal|
	Tex: 控制 iskeyword				|g:tex_isk|

				*tex-folding* *g:tex_fold_enabled*
 Tex: 要語法摺疊麼？ ~

<syntax/tex.vim> 的版本 28 支持基於語法的 part、chapter、section、subsection
等等的摺疊。把 >
	let g:tex_fold_enabled=1
放到你的 <.vimrc> 裏，並 :set fdm=syntax。我建議把後者放到你的 LaTeX 文件末尾
的模式行裏來執行: >
	% vim: fdm=syntax
如果系統過慢，可以看看 >
	https://vimhelp.appspot.com/vim_faq.txt.html#faq-29.7
<
						*g:tex_nospell*
 Tex: 不想拼寫檢查~

如果不想 LaTeX 文檔在任何地方檢查拼寫，在 .vimrc 里加入 >
	let g:tex_nospell=1
如果只想關閉註釋中的拼寫檢查，見 |g:tex_comment_nospell|。

				*tex-nospell* *g:tex_comment_nospell*
 Tex: 不想檢查註釋裏的拼寫？ ~

有些傢伙喜歡在註釋裏寫源代碼，所以希望在 LaTeX 文件的註釋裏關閉拼寫檢查。爲
此，在 <.vimrc> 裏放上: >
      let g:tex_comment_nospell= 1
如果你要關閉 LaTeX 文檔中所有地方的拼寫檢查，見 |g:tex_nospell|。

				*tex-verb* *g:tex_verbspell*
 Tex: 需要在 Verbatim 區中使用拼寫檢查？~

通常 verbatim 區域用於源代碼這類的東西；很少有人想對源代碼進行拼寫檢查。如果你
真的想要對 verbatim 區進行拼寫檢查，在 <.vimrc> 裏放入: >
	let g:tex_verbspell= 1
<
					*tex-runon* *tex-stopzone*
 Tex: 在註釋還是數學模式裏？~

<syntax/tex.vim> 高亮支持 TeX、LaTeX 和部分的 AmsTeX。高亮支持包括三個主要的區
域: normal、texZone 和 texMathZone。儘管付出了相當的努力使得這些區域能正確地
終止，$..$ 和$$..$$ 定界的區域無法同步，因爲開始和結束模式無法區別。因而，提供
了一個特殊的 "TeX 註釋" >
	%stopzone
它會使得 texZone 或 texMathZone 強迫終止。

					*tex-slow* *tex-sync*
 Tex: 語法高亮很慢？~

如果你使用機器速度很慢，可能會想減小這些變量的值 >
	:syn sync maxlines=200
	:syn sync minlines=50
(特別是後者)。如果你的機器很快，可以考慮增大它們的值。它們主要影響同步 (確切地
說也就是: 如果有的話，哪個語法組包含屏幕頂部的文本？)。

另外一個高亮緩慢的原因是基於語法的摺疊；解決辦法見 |tex-folding|。

					*g:tex_fast*

最後，如果語法高亮還是太慢，可以在 .vimrc 裏設置

	:let g:tex_fast= ""

g:tex_fast 變量使得語法高亮腳本避免定義任何語法區域和相關的同步。這使得語法高
亮速度大大加快；作爲代價：高亮和基於語法的摺疊會少很多，也不能進行基於語法的
錯誤檢查。

可以選擇接受若干而非全部的語法項目；用下表可以選擇性地打開部分語法高亮: >

    b : 接受粗體和斜體語法
    c : 接受 texComment 語法
    m : 接受 texMatcher 語法 (即 {...} 和 [...])
    M : 接受 texMath 語法
    p : 接受 部分、章節、小節等的語法
    r : 接受 texRefZone 語法 (nocite、bibliography、label、pageref、eqref)
    s : 接受 上標/下標區域
    S : 接受 texStyle 語法
    v : 接受 verbatim 語法
    V : 接受 texNewEnv 和 texNewCmd 語法
<
例如，g:tex_fast= "M" 會打開數學相關的高亮但關閉其他基於區域的語法高亮。

					    *tex-morecommands* *tex-package*
 Tex: 想高亮更多的命令？ ~

LaTeX 是可編程的語言，因而有數以千計的包，包含各種專門的 LaTeX 命令、語法和字
體。如果你用了某個包，當然希望發佈的 syntax/tex.vim 能支持它。但這顯然是不實際
的。請考慮使用 |mysyntaxfile-add| 介紹的技術來擴展或者修改 syntax/tex.vim 提供
的高亮處理。任何你編寫的擴展一般應放在 $HOME/after/syntax/tex/[pkgname].vim，
並請考慮上傳到 http://vim.sf.net/。

					*tex-error* *g:tex_no_error*
 Tex: 過多的 Error 高亮？~

<tex.vim> 支持各種的詞法檢查。儘管錯誤檢查經常很有用，它指示的地方實際上可能沒
有錯誤。如果你有這個問題，可以在 <.vimrc> 裏放上如下的語句: >
	let g:tex_no_error=1
從而 <tex.vim> 提供的所有錯誤檢查都會被抑制。

								*tex-math*
 Tex: 需要新的數學模式的組？~

如果你需要在 LaTeX 裏包含新的數學組，下面的代碼給出一個告訴你可以如何操作的例
子: >
	call TexNewMathZone(sfx,mathzone,starform)
你需要爲新數學組起一個獨一無二的後綴 (目前，A-L 和 V-Z 被 <syntax/tex.vim> 自
己佔用)。比如，看看 <syntax/tex.vm> 是怎麼設置 eqnarray 的: >
	call TexNewMathZone("D","eqnarray",1)
需要把 "mathzone" 換成新數學組的組名，然後在 .vim/after/syntax/tex.vim 裏調
用。如果 "starform" 變量爲真，意味着新數學組有星號的形式 (比如， eqnarray*)。

					*tex-style* *b:tex_stylish*
 Tex: 開始新的風格？~

你可以在 *.tex 文件裏使用 "\makeatletter"，從而在命令裏可用 "@"。不過，因爲
*.tex 文件沒有如下的後綴: sty cls clo dtx ltx，語法高亮會把這裏使用的 @ 標爲錯
誤。要解決這個問題: >

	:let b:tex_stylish = 1
	:set ft=tex

把 "let g:tex_stylish=1" 放到你的 <.vimrc> 裏，這會使得 <syntax/tex.vim> 總能
接受 @ 的這種使用方式。

					*tex-cchar* *tex-cole* *tex-conceal*
 Tex: 利用隱藏模式~

如果你設置 |'conceallevel'| 爲 2 而編碼是 utf-8，若干字符序列會翻譯爲合適的
utf-8 字形，包括各種重音字符、數學模式的希臘字母。數學模式的上標和下標。不是所
有的字符都可以轉爲上標和下標；這是由於 utf-8 支持的限制。事實上，只有很少的字
符支持下標。

一個用法是垂直分割窗口 (見 |CTRL-W_v|)；其中一個把 |'conceallevel'| 設爲 0，另
一個設爲 2；兩者都用 |'scrollbind'|。

					*g:tex_conceal*
 Tex: 選擇性的隱藏模式~

通過在 <.vimrc> 中設置 g:tex_conceal，可以有選擇性地使用隱藏模式。缺省的設置爲
"admgs"，隱藏以下對應的字符集合: >

	a = 重音/連寫體 (accents/ligatures)
	b = 粗體和斜體
	d = 定界符
	m = 數學符號
	g = 希臘字母
	s = 上標/下標
<
省略其中一個或幾個字符關閉對應的使用隱藏字符進行替代的操作。

						*g:tex_isk* *g:tex_stylish*
 Tex: 控制 iskeyword~

通常，LaTeX 關鍵字只支持 0-9, a-z, A-Z, 192-255。Latex 關鍵字不支持下劃線，除
了 *.sty 文件以外。語法高亮腳本使用以下的邏輯:

	* 如果 g:tex_stylish 存在且爲 1
		文件被作爲 "sty" 文件對待，允許 "_" 成爲關鍵字一的部分
		(獨立於 g:tex_isk)
	* 否則如果文件名後綴是 sty、cls、clo、dtx 或 ltx
		文件被作爲 "sty" 文件對待，允許 "_" 成爲關鍵字一的部分
		(獨立於 g:tex_isk)

	* 如果 g:tex_isk 存在，它被用作局部的 'iskeyword'
	* 否則局部的 'iskeyword' 設爲 48-57,a-z,A-Z,192-255


TF						*tf.vim* *ft-tf-syntax*

tf 語法高亮有一個選項。

同步的 minlines 缺省爲 100。如果你希望設爲別的值，可以把 "tf_minlines" 設爲你
希望的值。例如: >

	:let tf_minlines = 你的選擇
<
VIM			*vim.vim* 		*ft-vim-syntax*
			*g:vimsyn_minlines*	*g:vimsyn_maxlines*

準確的語法高亮和屏幕刷新速度需要一定的折衷。要提高準確性，你可能想增加
g:vimsyn_minlines 變量的值。而 g:vimsyn_maxlines 變量可以用來增加屏幕的刷新速
度 (詳情可見 |:syn-sync|)。

	g:vimsyn_minlines : 用於設置同步的 minlines
	g:vimsyn_maxlines : 用於設置同步的 maxlines

	(g:vim_minlines 和 g:vim_maxlines 是這些選項過時的名字)

						*g:vimsyn_embed*
g:vimsyn_embed 選項允許用戶選擇是否使用及使用何種類型的嵌入腳本高亮。 >

   g:vimsyn_embed == 0   : 不內嵌任何腳本
   g:vimsyn_embed =~ 'm' : 內嵌 mzscheme (僅當 vim 支持)
   g:vimsyn_embed =~ 'p' : 內嵌 perl     (僅當 vim 支持)
   g:vimsyn_embed =~ 'P' : 內嵌 python   (僅當 vim 支持)
   g:vimsyn_embed =~ 'r' : 內嵌 ruby     (僅當 vim 支持)
   g:vimsyn_embed =~ 't' : 內嵌 tcl      (僅當 vim 支持)
<
缺省，g:vimsyn_embed 是 "mpPr"；也就是說，syntax/vim.vim 缺省會支持 mzscehme、
perl、python 和 ruby 的高亮。Vim 的 has("tcl") 測試看來在 tcl 不存在的時候會掛
起。所以，缺省不支持嵌入 tcl (但如果你希望 vim 語法高亮包含 tcl 的內嵌的話，只
要簡單地在 g:vimembedscript 選項中加入便可)。
						*g:vimsyn_folding*

syntax/vim.vim 現在支持一些摺疊: >

   g:vimsyn_folding == 0 或不存在: 沒有基於語法的摺疊
   g:vimsyn_folding =~ 'a' : 自動命令組
   g:vimsyn_folding =~ 'f' : 摺疊函數
   g:vimsyn_folding =~ 'm' : 摺疊 mzscheme 腳本
   g:vimsyn_folding =~ 'p' : 摺疊 perl     腳本
   g:vimsyn_folding =~ 'P' : 摺疊 python   腳本
   g:vimsyn_folding =~ 'r' : 摺疊 ruby     腳本
   g:vimsyn_folding =~ 't' : 摺疊 tcl      腳本
<
							*g:vimsyn_noerror*
syntax/vim.vim 給出的錯誤高亮未必都正確；VimL 是一個要正確高亮難度很高的語言。
如果不想出現錯誤高亮，在你的 |vimrc| 裏放上: >

	let g:vimsyn_noerror = 1


XF86CONFIG				*xf86conf.vim* *ft-xf86conf-syntax*

XFree86 v3.x 和 v4.x 版本里，XF86Config 文件的語法有所不同。兩者都支持且有自動
檢測，但離完善還很遠。你可能仍然需要手動指定版本。根據你的 XFree86 的版本，在
.vimrc 裏把 xf86conf_xfree86_version 變量設爲 3 或 4。例如: >
	:let xf86conf_xfree86_version=3
如果混合使用多種版本，設置 b:xf86conf_xfree86_version 變量。

注意 不支持選項名的空格和下劃線。如果你想高亮選項名，使用 "SyncOnGreen" 而不是
"__s yn con gr_e_e_n"。


XML						*xml.vim* *ft-xml-syntax*

缺省高亮 Xml 的命名空間。設置了下面的全局變量以後可以繼承此設置: >

	:let g:xml_namespace_transparent=1
<
							*xml-folding*
xml 語法文件提供打開和關閉標籤間的語法摺疊 |folding| (見 |:syn-fold|)。這可以
用下面的代碼打開 >

	:let g:xml_syntax_folding = 1
	:set foldmethod=syntax
<
注意: 語法摺疊會顯著地減慢語法高亮。大文件尤其如此。


X Pixmaps (XPM)					*xpm.vim* *ft-xpm-syntax*

xpm.vim 根據 XPM 文件的內容動態地建立語法項目。這樣你就可以修改色彩規格字符
串。修改後，可用 ":set syn=xpm" 再次執行。

要複製帶某顏色的像素，使用 "yl" 命令抽出 "像素" 然後在別的地方使用 "P" 插入。

你想用鼠標畫圖麼？試試這些代碼: >
   :function! GetPixel()
   :   let c = getline(".")[col(".") - 1]
   :   echo c
   :   exe "noremap <LeftMouse> <LeftMouse>r".c
   :   exe "noremap <LeftDrag>	<LeftMouse>r".c
   :endfunction
   :noremap <RightMouse> <LeftMouse>:call GetPixel()<CR>
   :set guicursor=n:hor20	   " 可以看到光標下的顏色
這使得右鍵變成像素提取工具，而左鍵成爲一支筆。該代碼只可用於每個像素一個字符的
XPM 文件，而且你不能在像素字符串之外點擊。不過，你自己可以嘗試改進之。

如果使用大小減半的字體，看其來會舒服得多。比如，在 X 上: >
	:set guifont=-*-clean-medium-r-*-*-8-*-*-*-*-80-*

==============================================================================
5. 定義語法						*:syn-define* *E410*

Vim 理解三種語法項目的類型:

1. 關鍵字
   它只能包含由 'iskeyword' 選項定義的關鍵字字符，而且不能包含其它語法項目。
   它必須匹配完整的單詞 (在匹配的前後不能有其它的關鍵字字符)。
   關鍵詞 "if" 只在 "if(a=b)" 裏匹配，而不在 "ifdef x" 裏匹配。因爲 "(" 不是關
   鍵字字符，但 "d" 是。

2. 匹配
   它匹配單個正規表達式模式。

3. 區域
   它始於 "start" 正規表達式模式的匹配，結束於 "end" 正規表達式模式的匹配。兩
者之間可以包含任何文本。其中，"skip" 正規表達式模式可以用來避免 "end" 模式的匹
配。

若干語法*項目*可以放在一個語法*組*裏。你可以爲一個語法組設置高亮屬性。例如，你
可以定義 "/* .. */" 註釋爲一個項目，"// .." 註釋爲另一個，並把兩者都放在
"Comment" 組裏。這時，你就可以設置 "Comment" 以粗體字體和藍色出現。你可以自由
選擇各種組合，比如爲每個語法項目設置一個高亮組，乃至把所有項目都放到一個組。這
取決於你如何指定你的高亮屬性。把每個項目放到單獨的組裏的後果是你需要爲很多組指
定高亮屬性。

注意 語法組和高亮組類似。你爲高亮組指定高亮屬性，而這些屬性會被用於同名的語法
組。

如果有多個項目在相同位置匹配，*最後*定義的那個勝出。這樣，你可以覆蓋較早定義的
匹配相同文本的語法項目。不過，關鍵字總是優先於匹配和區域，而匹配大小寫的關鍵字
又優先於忽略大小寫的關鍵字。


優 先 級						*:syn-priority*

如果多個語法項目可以匹配，使用如下規則:

1. 如果多個匹配或區域項目在相同的位置開始，最後定義者優先。
2. 關鍵字比匹配和區域項目優先。
3. 從較早位置開始的項目優先於從較後位置開始的項目。


定 義 大 小 寫 敏 感					*:syn-case* *E390*

:sy[ntax] case [match | ignore]
	要求其後的 ":syntax" 命令在本設定爲 "match" 時必須匹配大小寫，本設定爲
	"ignore" 時則可以忽略大小寫。注意，它不影響之前的項目，而隻影響其後直
	到下一個 ":syntax case" 命令爲止的所有項目。


拼 寫 檢 查						*:syn-spell*

:sy[ntax] spell [toplevel | notoplevel | default]
	定義不在任何語法項目裏的文本在何處進行拼寫檢查:

	toplevel:	文本進行拼寫檢查。
	notoplevel:	文本不進行拼寫檢查。
	default:	如果有 @Spell 簇，不進行拼寫檢查。

	語法項目裏的文本用 @Spell 和 @NoSpell 簇 |spell-syntax|。如果沒有
	@Spell 和 @NoSpell 簇，那麼 "default" 和 "toplevel" 進行拼寫檢查。

	要激活拼寫檢查，必須置位 'spell' 選項。


定 義 關 鍵 字						*:syn-keyword*

:sy[ntax] keyword {group-name} [{options}] {keyword} .. [{options}]

	定義一系列關鍵字。

	{group-name}	是語法組名，比如 "Comment"。
	[{options}]	見下 |:syn-arguments|。
	{keyword} ..	是關鍵字列表，這些關鍵字成爲該組的成員。

	示例: >
  :syntax keyword   Type   int long char
<
	{options} 可以在該行的任何位置給出。它們應用於所有的關鍵字，包括選項之
	前的關鍵字。以下例子完全相同: >
  :syntax keyword   Type   contained int long char
  :syntax keyword   Type   int long contained char
  :syntax keyword   Type   int long char contained
<								*E789*
	如果像 Vim 裏的 Ex 命令那樣，使用有可選尾部的關鍵字並把可選字符放在 []
	裏，你可以一次定義各種變化形式: >
  :syntax keyword   vimCommand	 ab[breviate] n[ext]
<
	不要忘記只有所有字符都包含在 'iskeyword' 選項裏才能作爲關鍵字識別。如
	果有一個字符不是，該關鍵字永遠不會被識別。不過，可以使用多字節字符，它
	們不需要出現在 'iskeyword' 裏。

	關鍵字比匹配和區域有更高的優先級。如果有多個項目匹配，會優先使用關鍵
	字。關鍵字不會嵌套，也不能包含其它項目。

	注意 你不能使用和選項同名的關鍵字 (即使這裏不允許的選項也不行)。這時，
	應該使用匹配。

	關鍵字的最大長度爲 80 個字符。

	根據被包含與否的不同，可以多次定義同一關鍵字，例如，你可以定義一次不被
	包含的關鍵字並使用一個高亮組。而爲被包含的同一關鍵字使用不同的高亮組。
	例如: >
  :syn keyword vimCommand tag
  :syn keyword vimSetting contained tag
<	如果發現獨立於別的語法項目之外的 "tag"，使用 "vimCommand" 高亮組。如果
	發現 "tag" 出現在能包含 "vimSetting" 的項目裏，則使用 "vimSetting"。


定 義 匹 配						*:syn-match*

:sy[ntax] match {group-name} [{options}] [excludenl] {pattern} [{options}]

	定義一個匹配。

	{group-name}		語法組名，比如 "Comment"。
	[{options}]		見下 |:syn-arguments|。
	[excludenl]		使得包含行尾匹配 "$" 的模式不擴展包含本項目的
				匹配或者區域項目。必須在模式之前給出。
				|:syn-excludenl|
	{pattern}		定義匹配的搜索模式。見下面的 |:syn-pattern|。
				注意 模式可以匹配多於一行的模式，這使得匹配依
				賴於 Vim 從哪裏開始搜索模式。你需要確信同步機
				制能正確處理這個問題。

	例如 (匹配字符常數): >
  :syntax match Character /'.'/hs=s+1,he=e-1
<

定 義 區 域 		*:syn-region* *:syn-start* *:syn-skip* *:syn-end*
							*E398* *E399*
:sy[ntax] region {group-name} [{options}]
		[matchgroup={group-name}]
		[keepend]
		[extend]
		[excludenl]
		start={start_pattern} ..
		[skip={skip_pattern}]
		end={end_pattern} ..
		[{options}]

	定義一個區域。區域可以覆蓋多行。

	{group-name}		語法組名，比如 "Comment"。
	[{options}]		見下 |:syn-arguments|。
	[matchgroup={group-name}]  其後定義的開始或者結束模式的匹配文本專用的
				語法組。該語法組並不用於兩者之間的文本。如果不
				想開始或結束匹配使用另外的語法組，可以用 NONE
				作爲組名來復位。
				見 |:syn-matchgroup|。
	keepend			不允許被包含的匹配項目越過結束模式的匹配文本。
				見 |:syn-keepend|。
	extend			否決包含本區域的項目的 "keepend" 設置。見
				|:syn-extend|。
	excludenl		使得包含行尾匹配 "$" 的模式不擴展包含本項目的
				匹配或者區域。只適用於結束模式。必須在該模式之
				前給出。|:syn-excludenl|
	start={start_pattern}	定義區域開始的搜索模式。見下 |:syn-pattern|。
	skip={skip_pattern}	定義不需要查找結束模式的區域內部文本的搜索模
				式。見下 |:syn-pattern|。
	end={end_pattern}	定義區域結束的搜索模式。見下 |:syn-pattern|。

	示例: >
  :syntax region String   start=+"+  skip=+\\"+  end=+"+
<
	開始 / 跳過 / 結束模式和其它選項可用任何順序給出。跳過模式可有零到一
	個。開始和結束模式必須有一個或更多。這意味着，你可以忽略跳過模式，但你
	必須給出至少一個的開始和結束模式。在等號前後，可以使用空白字符 (不過多
	數情況下，其實沒有空白字符更清楚一些)。

	如果給出多於一個的開始模式，只須匹配其中任何一個。這意味着這些開始模式
	之間是*或*的關係。如有多個匹配，使用最後一個。結束模式也是如此。

	結束模式從開始模式之後立即開始搜索，這裏不考慮位移。這意味着，結束模式
	的匹配文本永遠不會與開始模式的重疊。

	跳過和結束模式可以跨行匹配，但因爲模式的搜索可以從任何一行開始，這經常
	不能如你所願。跳過模式也不能避免下一行中結束模式的匹配。要避免麻煩，最
	好使用單行的模式。

	注意: 一個區域的開始完全取決於開始模式的匹配。不檢查是否存在結束模式的
	匹配。下面_不能_工作: >
		:syn region First  start="("  end=":"
		:syn region Second start="("  end=";"
<	Second 總是在 First 之前得到匹配 (最後定義的模式享有更高的優先權)。
	Second 區域會繼續到後面出現的 ';' 爲止。這之前是否出現 ':' 無關緊要。
	要解決這個問題，可以使用匹配: >
		:syn match First  "(\_.\{-}:"
		:syn match Second "(\_.\{-};"
<	該模式使用 "\_." 匹配任何字符或換行符，並以 "\{-}" 重複 (重複儘量少的
	次數)。

							*:syn-keepend*
	缺省，被包含的項目可以隱藏結束模式的匹配。這對嵌套有用。比如， "{" 開
	始 "}" 結束的區域可以包含另一個這樣的區域。第一個遇到的 "}" 會結束被包
	含的區域，不是外面的那個:
	    {		開始外層 "{}" 區域
		{	開始被包含的 "{}" 區域
		}	結束被包含的 "{}" 區域
	    }		結束外層 "{} 區域
	如果你不希望如此，"keepend" 參數可以使得外層區域結束模式的匹配同時結束
	任何包含在內的項目。這使得相同區域的嵌套不再可能，但可以允許被包含項目
	高亮結束模式的部分內容，而不會因此跳過結束模式的匹配。例如: >
  :syn match  vimComment +"[^"]\+$+
  :syn region vimCommand start="set" end="$" contains=vimComment keepend
<	"keepend" 使得 vimCommand 總是在行尾結束，即使被包含的 vimComment 包括
	了 <EOL> 的匹配也不例外。

	如果不使用 "keepend"，在每個被包含項目的匹配文本之後，纔會重新嘗試結束
	模式的匹配。如果使用 "keepend"，尋找結束模式第一次出現的匹配，並截斷任
	何被包含的項目。
							*:syn-extend*
	"keepend" 的行爲可以被 "extend" 參數改變。當一個項目使用 "extend" 的時
	候，包含它的外層項目所用的 "keepend" 被忽略，從而使得那個項目可以得到
	擴展。
	這可以使一些被包含的項目能擴展某區域，而另一些則不能。例如: >

   :syn region htmlRef start=+<a>+ end=+</a>+ keepend contains=htmlItem,htmlScript
   :syn match htmlItem +<[^>]*>+ contained
   :syn region htmlScript start=+<script+ end=+</script[^>]*>+ contained extend

<	這裏，htmlItem 項目不擴展 htmlRef 項目，它只是用來高亮 <> 條目。而
	htmlScript 項目則擴展 htmlRef 項目。

	另一個例子: >
   :syn region xmlFold start="<a>" end="</a>" fold transparent keepend extend
<	定義使用 "keepend" 的區域，使得它的結尾不會被包含在內的項目所改變，比
	如匹配 "</a>" 以賦予不同高亮屬性的那些項目。但如果 xmlFold 區域本身嵌
	套 (自己包含自己)，則應用 "extend"，使得嵌套在內的 "</a>" 只會結束裏面
	的區域，而不是包含該區域的外層區域。

							*:syn-excludenl*
	當一個匹配項目的模式或者區域項目的結束模式包含 '$' 以匹配行尾的時候，
	包含該項目的外部區域項目會在下一行繼續。比如，使用 "\\$" (行尾出現的反
	斜槓) 的匹配項目可以使得一個通常在行尾結束的區域繼續下去。這是缺省的行
	爲。如果你不希望如此，有兩個解決方法:
	1. 外部項目使用 "keepend"。這會使得所有被包含的項目不能擴展外部的匹配
	   或區域項目。這可用於所有被包含的項目都不能擴展外部項目的場合。
	2. 在被包含的項目中使用 "excludenl"。這使得該匹配不能擴展外部的匹配或
	   區域項目。這可用於只有一些被包含的項目不需要擴展外部項目的場合。
	   "excludenl" 必須在它適用的模式之前給出。

							*:syn-matchgroup*
	"matchgroup" 可以用來高亮開始和/或結束模式，使之和區域本體不同。例
	如: >
  :syntax region String matchgroup=Quote start=+"+  skip=+\\"+	end=+"+
<	會使得引號本身使用 "Quote" 組高亮。而其中的文本使用 "String" 高亮組。
	"matchgroup" 用於其後所有的開始和結束模式，直到下一個 "matchgroup" 爲
	止。使用 "matchgroup=NONE" 回到不使用 matchgroup 的情況。

	用 "matchgroup" 高亮的開始或結束模式的匹配文本不會用於包含在該區域內的
	項目。這樣可以避免被包含項目也能在開始或結束模式的匹配文本中匹配。
	"transparent" 選項不適用於使用 "matchgroup" 高亮的開始或結束模式的匹配
	文本。

	這裏是一個例子，它以不同的顏色高亮三層括號: >
   :sy region par1 matchgroup=par1 start=/(/ end=/)/ contains=par2
   :sy region par2 matchgroup=par2 start=/(/ end=/)/ contains=par3 contained
   :sy region par3 matchgroup=par3 start=/(/ end=/)/ contains=par1 contained
   :hi par1 ctermfg=red guifg=red
   :hi par2 ctermfg=blue guifg=blue
   :hi par3 ctermfg=darkgreen guifg=darkgreen
<
						*E849*
語法組的最大數目爲 19999。

==============================================================================
6. :syntax 參數						*:syn-arguments*

定義語法項目的 :syntax 命令接受多個參數。其中，通用的部分在這裏解釋。這些參數
可以用任何順序給出，也可和模式相互間雜。

不是所有的命令都接受每個參數。下表顯示什麼參數不能在所有命令裏使用:
							*E395*
		    contains  oneline	fold  display  extend concealends~
:syntax keyword		 -	 -	 -	 -	 -	 -
:syntax match		是	 -	是	是	是	 -
:syntax region		是	是	是	是	是	是

以下參數可以在所有三個命令裏使用:
	conceal
	cchar
	contained
	containedin
	nextgroup
	transparent
	skipwhite
	skipnl
	skipempty

conceal						*conceal* *:syn-conceal*

如果給出 "conceal" 參數，本項目被標爲可隱藏。實際隱藏與否取決於 'conceallevel'
選項的值。'concealcursor' 選項決定當前行的可隱藏項目是否會以正常方式顯示，以便
對本行進行編輯。

concealends						*:syn-concealends*

如果給出 "concealends" 參數，區域的開始和結束匹配 (不包括區域內容本身) 被標爲
可隱藏，實際隱藏與否取決於 'conceallevel' 選項的設置。只有這種方式，區域結束處
纔可以用 "matchgroup" 來定義自己單獨的高亮隱藏方式。

cchar							*:syn-cchar*
							*E844*
"cchar" 參數定義代替可隱藏項目的字符 (只有給出 conceal 參數時設置 "cchar" 纔有
意義)。如果沒有給出 "cchar"，缺省的隱藏代替字符是 'listchars' 選項定義的字符。
該字符不能是控制字符，如製表符。示例: >
   :syntax match Entity "&amp;" conceal cchar=&
關於高亮，見 |hl-Conceal|。

contained						*:syn-contained*

如果給出 "contained" 參數，本項目在頂層不會被識別。只有包含在另外一個項目裏才
可以，而且那個項目必須給出 "contains" 參數且其中包含本項目。例如: >
   :syntax keyword Todo    TODO    contained
   :syntax match   Comment "//.*"  contains=Todo


display							*:syn-display*

如果給出 "display" 參數，本項目會在檢測到高亮不會顯示的時候被跳過。這樣，高亮
速度可以加快，因爲只要發現要顯示的文本的語法狀態就可以跳過本項目。

通常，你使用 "display" 來匹配滿足以下條件的匹配和區域項目:
- 該項目不會跨過行尾。C 的例子: 包含 "/*" 的註釋不能使用 "display"，因爲它會在
  下一行繼續。
- 該項目不包含會跨過行尾或使得本項目在下一行繼續的項目。
- 該項目不改變任何包含它在內的項目的大小。C 的例子: 預處理指令裏的匹配 "\\$"
  不能使用 "display"，因爲它可以使得預處理指令的匹配變短。
- 該項目不允許其它項目匹配本來不能匹配的內容，而所擴展的匹配文本會走的太遠。C
  的例子: 定義 "//" 註釋的匹配不能使用 "display"，因爲在該註釋裏的 "/*" 這時會
  匹配並開始一個跨越行尾的註釋。

例如，在 C 程序裏，"display" 可以用在:
- 數值的匹配
- 標籤的匹配


transparent						*:syn-transparent*

如果給出 "transparent" (透明) 參數，本項目自身不會被高亮，但會使用包含它的外層
項目的高亮屬性。這對本身不需要特殊高亮但要用來跳過一段文本的語法項目有用。

除非包含 transparent 的這個項目本身包含了 "contains" 參數，"contains="
參數會從外層的項目繼承，要避免包含不需要的項目，可使用 "contains=NONE"。例如，
高亮字符串裏的單詞，但不包括 "vim": >
	:syn match myString /'[^']*'/ contains=myWord,myVim
	:syn match myWord   /\<[a-z]*\>/ contained
	:syn match myVim    /\<vim\>/ transparent contained contains=NONE
	:hi link myString String
	:hi link myWord   Comment
"myVim" 匹配出現在 "myWord" 之後，因而它是更優先的匹配 (在相同的位置上，後出
現的匹配優先於先出現的匹配)。"transparent" 參數使得 "myVim" 的匹配使用和
"myString" 相同的高亮，但它本身不再包含其它項目。如果沒有指定 "contains=NONE"
參數，那麼 "myVim" 會使用 myString 的 contains 參數，從而包含了 "myWord"，因而
被高亮爲 Constant (譯者注: 應爲 Comment)。這之所以會發生，是因爲被包含的項目不
會在同樣的位置上匹配外層同一個語法項目，所以這裏，在最內層的 "myVim" 匹配不能
否決 "myWord" 的匹配。

如果你看有色彩的文本，它實際上是由一層層被包含的項目組成的。被包含的項目在包含
它的項目之上，因而你能看到被包含的項目。如果一個被包含的項目是透明的，你會看透
它，從而看到包含它的項目。以圖示之:

		從這裏看

	    |	|   |	|   |	|
	    V	V   V	V   V	V

	       xxxx	  yyy		被包含更深的項目
	    ....................	被包含項目 (透明)
	=============================	第一個項目

'x'、'y' 和 '=' 分別表示一種高亮的語法項目。'.' 代表透明層。

你實際看到的是:

	=======xxxx=======yyy========

這裏，你 "看穿" 了透明的 "...."。


oneline							*:syn-oneline*

"oneline" 參數指示本區域不會跨過行邊界。它必須在當前行內完整匹配。不過，如果本
區域包含跨行的項目，那麼本區域還是會從下一行繼續。被包含的項目可以用來識別續行
模式。不過，結束模式必須仍然在第一行上匹配，不然本區域根本不會開始。

如果開始模式包含 "\n" 從而匹配換行符，結束模式必須在開始模式結束處所在的同一行
上找到。該結束模式也可以包含換行符。因而，"oneline" 參數只是意味着開始模式的結
束處和結束模式的開始處必須在同一行上。這一點，即使跳過模式包含換行符也不能改
變。


fold							*:syn-fold*

"fold" 參數使得本項目的摺疊級別加 1。示例: >
   :syn region myFold start="{" end="}" transparent fold
   :syn sync fromstart
   :set foldmethod=syntax
這使得每個 {} 塊形成一個摺疊。

該摺疊從項目開始的行開始，而在項目結束之行上結束。如果開始和結束處在同一行，則
不形成摺疊。'foldnestmax' 選項限制語法摺疊的嵌套級別。
{僅當 Vim 編譯時帶 |+folding| 特性纔有效}


			*:syn-contains* *E405* *E406* *E407* *E408* *E409*
contains={groupname}...

"contains" 參數跟隨語法組名的列表。這些組因而被允許包含在本項目裏 (它們可能擴
展包含它們的組的結束位置)。這使得匹配和區域的遞歸嵌套成爲可能。如果沒有
"contains" 參數，本項目不能包含任何組。組名不需要在這裏的使用前定義。

contains=ALL
		如果唯一在包含列表裏出現的名字是 "ALL"，那麼本項目裏可以包含所
		有的組。

contains=ALLBUT,{group-name}...
		如果包含列表的第一個名字是 "ALLBUT"，那麼除了列出的那些以外，
		所有的組都可以出現在本項目裏。例如: >
  :syntax region Block start="{" end="}" ... contains=ALLBUT,Function

contains=TOP
		如果包含列表的第一個名字是 "TOP"，那麼所有不包含 "contained"
		參數的組都可以接受。
contains=TOP，{group-name},..
		類似於 "TOP"，但除了列出的組以外。

contains=CONTAINED
		如果包含列表的第一個名字是 "CONTAINED"，那麼所有包含
		"contained" 參數的組都可以接受。
contains=CONTAINED，{group-name},..
		類似於 "CONTAINED"，但列出的組除外。


"contains" 列表裏的 {group-name} 可以是模式。所有匹配該模式的組名都會包含進來
(或者排除出去，如果使用 "ALLBUT" 的話)。該模式不能包含空白或者 ','。例如: >
   ... contains=Comment.*,Keyw[0-3]
在執行 syntax 命令時完成該匹配。後來定義的組不會再參與匹配。另外，如果本
syntax 命令自己定義一個新組，它也不會參與匹配。小心: 在文件裏放入 syntax 命令
的時候，你不能指望某些組_沒有_定義，因爲該文件以前可能已經執行過。而
":syn clear" 並不會刪除組名。

被包含的組也會匹配一個區域項目的開始和結束模式。如果不想如此，可以用
"matchgroup" 參數 |:syn-matchgroup|。"ms=" 和 "me=" 位移可以用來調整被包含項
目能夠匹配的區域。注意 這同時可能限制了高亮的區域。


containedin={groupname}...				*:syn-containedin*

"containedin" 參數跟隨語法組名的列表。然後，本項目就可以包含在那些組裏，就像那
些項目使用了包含本項目的 "contains=" 參數一樣。

{groupname}... 的使用方式和 "contains" 相同，見上面的解釋。

這可以用於後加的語法項目。一個項目可以告知要包含在已經存在的項目裏面，而無須修
改後者的定義。例如，要在載入 C 語法以後高亮 C 註釋裏的一個單詞:
	:syn keyword myword HELP containedin=cComment contained ~
注意 同時使用了 "contained" 參數是爲了避免本項目在頂層得到匹配。

"containedin" 的匹配被加到該項目可以出現的其它地方。像平常一樣，本項目也可以使
用 "contains" 參數。不要忘記關鍵字項目不可能包含其它項目。所以把它們加在
"containedin" 裏是徒勞的。


nextgroup={groupname}...				*:syn-nextgroup*

"nextgroup" (下一個組) 參數跟隨語法組名的列表，以逗號分隔 (和 "contains" 類
似，你也可以使用模式)。

如果給出 "nextgroup" 參數，提到的語法組會在本匹配或區域結束之後嘗試匹配。如果
沒有一個組能夠匹配，高亮和平常一樣繼續。如果有匹配，則使用匹配的組高亮，即使該
組沒有在當前組的 "contains" 字段裏提到，就像這裏的組給賦予了比其它的組更高的優
先級一樣。例如: >
   :syntax match  ccFoobar  "Foo.\{-}Bar"  contains=ccFoo
   :syntax match  ccFoo     "Foo"	    contained nextgroup=ccFiller
   :syntax region ccFiller  start="."  matchgroup=ccBar  end="Bar"  contained

會分別高亮 "Foo" 和 "Bar"，但只有在 "Bar" 跟在 "Foo" 之後才行。在下面的文本行
裏，"f" 顯示使用 ccFoo 的高亮，而 "bbb" 則是使用 ccBar 的地方。

   Foo asdfasd Bar asdf Foo asdf Bar asdf
   fff	       bbb	fff	 bbb

注意 ".\{-}" 的使用跳過儘可能少的內容以到達下一個 Bar。如果使用了 ".*"，"Bar"
和 "Foo" 之間的 "asdf" 會以 "ccFoobar" 組高亮，因爲 ccBar 匹配行內第一個 "Foo"
和最後一個 "Bar" 的全部內容 (見 |pattern|)。


skipwhite						*:syn-skipwhite*
skipnl							*:syn-skipnl*
skipempty						*:syn-skipempty*

這些參數只能和 "nextgroup" 組合使用。它們可以用來指定如何跳過一些文本到達下一
個組:
	skipwhite	跳過空格和制表字符
	skipnl		跳過換行符
	skipempty	跳過空行 (意味着 "skipnl")

如果 "skipwhite" 存在，空白字符只有在沒有下一個組會匹配空白時纔會跳過。

如果 "skipnl" 存在，下一個組的匹配會在第二行內尋找。這只有在當前項目在行尾結束
時纔會發生！如果 "skipnl" 不存在，下一個組只會在當前項目相同的行上尋找。

如果在尋找下一個組時跳過文本，其它組的匹配就會忽略。只有在沒有下一個組匹配時，
其它的項目纔會重新嘗試被匹配。這意味着下一個組，包括跳過的空白和 <EOL>，的匹配
比其它項目的優先級要高。

示例: >
  :syn match ifstart "\<if.*"	nextgroup=ifline skipwhite skipempty
  :syn match ifline  "[^ \t].*" nextgroup=ifline skipwhite skipempty contained
  :syn match ifline  "endif"	contained
注意 "[^ \t].*" 匹配所有的非空白文本。這樣，它也能匹配 "endif"。所以 "endif"
匹配項目必須放在最後，以取得優先權。
注意 本例子不適用於嵌套的 "if"。你需要加上 "contains" 參數才行 (本例之所以省
略，是爲了簡潔起見)。

隱 含 隱 藏						*:syn-conceal-implicit*

:sy[ntax] conceal [on|off]
	指令後續的 ":syntax" 命令所定義的關鍵字、匹配或區域是否會自動帶上
	"conceal" 標誌位。":syn conceal on" 之後的所有 ":syn keyword"、
	":syn match" 或 ":syn region" 會隱含地帶上 "conceal" 標誌位。而
	":syn conceal off" 回覆到正常狀態，必須顯式給出 "conceal" 標誌位。

==============================================================================
7. 語法模式					*:syn-pattern* *E401* *E402*

在 syntax 命令裏，模式必須被兩個相同的字符包圍。這和 ":s" 命令類似。最常用的是
雙引號。但如果模式本身包含雙引號，你可以使用別的不在模式裏出現的字符。例如: >
  :syntax region Comment  start="/\*"  end="\*/"
  :syntax region String   start=+"+    end=+"+	 skip=+\\"+

關於模式的解釋，見 |pattern|。對語法模式的解釋總是假設打開了 'magic' 選項，而
與實際的 'magic' 值無關。而且也假設 'cpoptions' 裏沒有 'l' 標誌位。這些設置使
得語法文件易移植，而獨立於 'compatible' 和 'magic' 的設置。

要避免能夠匹配空字符串的模式，比如 "[a-z]*"。這會顯著減慢高亮，因爲這樣的模式
會在任何地方得到匹配。

						*:syn-pattern-offset*
模式可以後跟一個字符位移。它可以用來修改高亮的部分，也可以修改匹配或區域項目的
文本區域 (只有其它項目的匹配會受影響)。兩者都是相對於已經匹配的模式的。跳過模
式的字符位移可以用來指示從哪裏開始繼續尋找結束模式。

位移的形式是 "{what}={offset}"
{what} 可以是七種字符串之一:

ms	匹配開始	匹配文本開始的偏移
me	匹配結束	匹配文本結束的偏移
hs	高亮開始	高亮開始的偏移
he	高亮結束	高亮開始的偏移
rs	區域開始	區域本體開始的偏移
re	區域結束	區域本體結束的偏移
lc	引導上下文	超越模式的 "引導上下文" 的偏移

{offset} 可以是:

s	模式匹配部分的開始位置
s+{nr}	模式匹配部分的開始位置向右 {nr} 個字符
s-{nr}	模式匹配部分的開始位置向左 {nr} 個字符
e	模式匹配部分的結束位置
e+{nr}	模式匹配部分的結束位置向右 {nr} 個字符
e-{nr}	模式匹配部分的結束位置向左 {nr} 個字符
{nr}	(只用於 "lc"): 從開始處向右 {nr} 個字符開始匹配

例如: "ms=s+1"，"hs=e-2"，"lc=3"。

儘管所有的位移形式在任何模式之後都能接受，它們不都有意義。下表說明什麼樣的位移
在實際中會應用到:

		    ms	 me   hs   he	rs   re	  lc ~
匹配項目	    是   是   是   是 	-    -	  是
區域項目開始模式    是   -    是   -	是   -	  是
區域項目跳過模式    -	 是   -    -	-    -	  是
區域項目結束模式    -	 是   -    是 	-    是   是

位移可用 ',' 連接。例如: >
  :syn match String  /"[^"]*"/hs=s+1,he=e-1
<
    一些 "字符串" 文本
	  ^^^^^^		高亮部分

注意:
- 模式和位移字符之間不能有空白。
- 高亮區域永遠不會超出匹配文本的範圍。
- 結束模式上的負偏移不一定總能用，因爲結束模式可能在高亮本應結束的地方纔檢測
  到。
- Vim 7.2 之前，位移用字節數而不是字符數計算。這對多字節字符不適用，所以 Vim
  7.2 版本發行時改了。
- 匹配不能從實際匹配的模式所在的行之外開始。這樣不行: "a\nb"ms=e。高亮可以從另
  一個行開始，這樣沒有問題: "a\nb"hs=e。

示例 (匹配註釋，但不高亮 /* 和 */): >
  :syntax region Comment start="/\*"hs=e+1 end="\*/"he=s-1
<
	/* 這是一個註釋 */
	  ^^^^^^^^^^^^^^	  高亮部分

一個更複雜的例子: >
  :syn region Exa matchgroup=Foo start="foo"hs=s+2,rs=e+2 matchgroup=Bar end="bar"me=e-1,he=e-1,re=s-1
<
	 abcfoostringbarabc
	    mmmmmmmmmmm	    匹配
	      ssrrrreee	    高亮 開始 (s)/區域 (r)/結束 (e)
	      			("Foo"、"Exa" 和 "Bar")

引導上下文			*:syn-lc* *:syn-leading* *:syn-context*

注意: 這是一個已經廢棄的特性，包含它只是爲了和以前的 Vim 版本後向兼容。現在，
我們推薦使用在模式裏使用 |/\@<=| 構造。

"lc" 位移指定引導上下文 -- 模式的一部分: 必須存在，但不包含在實際的匹配中。形
如 "lc=n" 的位移會使得 Vim 在試圖匹配模式前先後退 n 列，從而可以使得已在較早的
模式中匹配的字符仍然可以做爲本匹配的引導上下文。這可用於，比如說，要求本匹配不
出現在某個前導的 "轉義" 字符之後: >

  :syn match ZNoBackslash "[^\\]z"ms=s+1
  :syn match WNoBackslash "[^\\]w"lc=1
  :syn match Underline "_\+"
<
	  ___zzzz ___wwww
	  ^^^	  ^^^	  匹配 Underline
	      ^ ^	  匹配 ZNoBackslash
		     ^^^^ 匹配 WNoBackslash

"ms" 位移自動設爲與 "lc" 位移相同的值，除非你顯式地設置 "ms"。


多行模式						*:syn-multi-line*

模式裏可以包含 "\n" 匹配換行符。多數情況下，它能正常工作，但有以下一些例外。

使用帶位移的開始模式時，匹配不允許從真實匹配之後的行開始。不過，高亮不存在這樣
的問題。"\zs" 項目也同樣需要匹配的開始不能移動到另一行。

跳過模式可以包含 "\n"，但結束模式的搜索會從下一行的第一個字符開始，即使跳過模
式匹配該字符也是如此。這是因爲重畫可以從區域中間的任何一行啓動，而不會檢查跳過
模式是否從那一行之前就已經開始的緣故。例如，如果跳過模式是 "a\nb" 而結束模式爲
"b"，結束模式的確會匹配下面情況的第二行: >
	 x x a
	 b x x
通常，這意味着跳過模式不應匹配 "\n" 之後的任何字符。


外部匹配						*:syn-ext-match*

以下附加的正規表達式項目可以用在區域項目的模式中:

					*/\z(* */\z(\)* *E50* *E52* *E879*
    \z(\)	標記該子表達式爲 "外部的"，這意味着它可以在別的模式匹配裏訪
		問。目前，只能在語法區域的開始模式中應用。

					*/\z1* */\z2* */\z3* */\z4* */\z5*
    \z1  ...  \z9			*/\z6* */\z7* */\z8* */\z9* *E66* *E67*
		匹配和前面的開始模式匹配裏相應子表達式的匹配的相同的字符串。

有時區域項目的開始和結束模式需要共享一個相同的子表達式。常見的例子是 Perl 和許
多 Unix 外殼裏的 "here" 文檔。這種效果可以通過特殊的 "\z" 正規表達式項目完成。
它把子表達式標爲 "外部的"，也就是說可以從定義所在的模式的外部引用。例如，here
文檔的例子可以如此完成: >
  :syn region hereDoc start="<<\z(\I\i*\)" end="^\z1$"

由此可見，\z 實際上有雙重任務。在開始模式裏，它標記 "\(\I\i*\)" 子表達式爲外部
的；在結束模式裏，它把 \1 反向引用重新定義爲指向開始模式裏的第一個外部子表達式
的外部引用。跳過模式裏也可以使用外部引用: >
  :syn region foo start="start \(\I\i*\)" skip="not end \z1" end="end \z1"
<
注意 普通和外部子表達式是完全不相關聯，它們分別索引。如果模式 "\z(..\)\(..\)"
應用於字符串 "aabb"，\1 會指向 "bb" 而 \z1 會指向 "aa"。也要 注意，外部子表達
式不能和普通的子表達式那樣，在同一個模式裏作爲反向引用來訪問。如果你需要把一個
子表達式同時作爲普通和外部子表達式來使用，可以嵌套使用這兩者，形如
"\(\z(...\)\)"。

注意 這裏只能使用行內的匹配，不能從外部引用多行匹配。

==============================================================================
8. 語法簇						*:syn-cluster* *E400*

:sy[ntax] cluster {cluster-name} [contains={group-name}..]
				 [add={group-name}..]
				 [remove={group-name}..]

本命令允許你把若干語法組捆綁在一起，以便使用單個名字訪問。

	contains={group-name}..
		本簇使用此處指定的組名列表。
	add={group-name}..
		將指定的組加入本簇。
	remove={group-name}..
		將指定的組從本簇裏刪除。

用這種方式定義的簇可以在 contains=..、containedin=..、nextgroup=..、add=.. 或
者 remove=.. 的列表裏使用，只要加上 "@" 前綴即可。用這種表示方式，你可以隱含地
在指定一個簇的內容之前先聲明之。

示例: >
   :syntax match Thing "# [^#]\+ #" contains=@ThingMembers
   :syntax cluster ThingMembers contains=ThingMember1,ThingMember2

如同前例所暗示的，對簇的修改追溯既往；可以說，在最後一刻才進行簇成員身份的檢
查: >
   :syntax keyword A aaa
   :syntax keyword B bbb
   :syntax cluster AandB contains=A
   :syntax match Stuff "( aaa bbb )" contains=@AandB
   :syntax cluster AandB add=B	  " 現在兩個關鍵字都在 Stuff 裏匹配

對嵌套的簇而言，這也有若干意含: >
   :syntax keyword A aaa
   :syntax keyword B bbb
   :syntax cluster SmallGroup contains=B
   :syntax cluster BigGroup contains=A,@SmallGroup
   :syntax match Stuff "( aaa bbb )" contains=@BigGroup
   :syntax cluster BigGroup remove=B	" 沒有效果，因爲 B 不在 BigGroup 裏
   :syntax cluster SmallGroup remove=B	" 現在 Stuff 不再匹配 bbb
<
						*E848*
簇的最大數目是 9767。

==============================================================================
9. 包含語法文件						*:syn-include* *E397*

一個語言的語法文件經常需要包含相關語言的語法文件。取決於它們實際的關係，可以用
兩種不同的方式完成:

	- 如果允許被包含的語法文件裏的頂層的語法項目也出現在包含它的語法的頂層
	  中，可以簡單的使用 |:runtime| 命令: >

  " 在 cpp.vim 裏:
  :runtime! syntax/c.vim
  :unlet b:current_syntax

<	- 如果被包含的語法文件裏的頂層語法項目應在包含它的語法的某區域中應用，
	  可以使用 ":syntax include" 命令:

:sy[ntax] include [@{grouplist-name}] {file-name}

	  被包含文件裏定義所有的語法項目會自動加上 "contained" 標誌。同時，如
	  果指定了組羣 (簇)，被包含文件所有的頂層語法項目會加到該組羣裏。 >

   " 在 perl.vim 裏:
   :syntax include @Pod <sfile>:p:h/pod.vim
   :syntax region perlPOD start="^=head" end="^=cut" contains=@Pod
<
	  如果 {file-name} 是絕對路徑 (以 "/"、"c:"、"$VAR" 或者 "<sfile>" 開
	  始)，則載入該文件。如果它是是相對路徑 (例如，"syntax/pod.vim")，則先
	  在 'runtimepath' 裏搜索該文件，然後載入所有匹配的文件。建議使用相對
	  路徑，因爲它允許用戶用自己的版本替代被包含的文件，而不用修改使用
	  ":syn include" 命令的文件。

						*E847*
包含的最大數目是 999。

==============================================================================
10. 同步					*:syn-sync* *E403* *E404*

Vim 期待在文檔的任何位置都能開始重畫過程。爲此目的，它需要知道重畫開始所在的位
置相應的語法狀態。

:sy[ntax] sync [ccomment [group-name] | minlines={N} | ...]

有四個同步方法:
1. 總是從文件頭開始分析。
   |:syn-sync-first|
2. 基於 C 風格的註釋。Vim 理解 C 註釋的工作方式，因而可以發現當前行是在註釋裏
   面還是外面。
   |:syn-sync-second|
3. 回跳若干行，從那裏開始分析。
   |:syn-sync-third|
4. 反向搜索某模式的匹配文本，從那裏開始同步。
   |:syn-sync-fourth|

				*:syn-sync-maxlines* *:syn-sync-minlines*
對於後三個方法而言，開始分析所在的行範圍受到 "minlines" 和 "maxlines" 的限制。

如果給出 "minlines={N}" 參數，分析總是至少倒退給出的行數，然後纔開始。這適用於
分析過程在能判斷正確之前至少需要若干行的情況、或者完全無法使用同步機制的場合。

如果給出 "maxlines={N}" 參數，反向搜索註釋或者同步用搜索模式的行數限於 N 行之
內 (包括 "minlines" 指定的行數)。可用於同步的項目較少且機器較慢的場合。例如:
>
   :syntax sync ccomment maxlines=500
<
						*:syn-sync-linebreaks*
使用可以匹配多行的模式時，某行的改變可以使得匹配不再能從上一行開始匹配。這意味
着同步必須從改變發生所在位置之前就進行。具體需要多少行可由 "linebreaks" 參數指
定。例如，如果模式包含一個換行符，可以這樣: >
   :syntax sync linebreaks=1
結果是，重畫至少從改變所在之前的一行開始。缺省的 "linebreaks" 值爲零。通常，
"minlines" 的值比 "linebreaks" 要大。


第一種同步方法:				*:syn-sync-first*
>
   :syntax sync fromstart

文件從頭開始分析。這使得語法高亮完全準確，但對很長的文件需時也久。Vim 預存以前
分析過的文本，所以只有第一次分析文本的時候纔會緩慢。不過，如果修改了文本，其後
的部分需要重新分析 (最差情況下: 一直到文件尾)。

使用 "fromstart" 等價於把 "minlines" 指定爲很大的數字。


第二種同步方法:				*:syn-sync-second* *:syn-sync-ccomment*

第二種方法只需指定 "ccomment" 參數。示例: >
   :syntax sync ccomment

Vim 如果發現顯示開始的行出現在 C 風格註釋的內部，就使用組名爲 "Comment" 的最後
一個區域語法項目。這需要組名爲 "Comment" 的區域項目存在！也可指定替代的組名，
例如: >
   :syntax sync ccomment javaComment
這意味着最後出現的 "syn region javaComment" 會用來檢測 C 註釋的區域。只有該區
域確實包含了開始模式 "\/*" 和結束模式 "*\/" 的時候纔能有效。

"maxlines" 參數可以用來限制搜索的行數。"minlines" 參數用來指定至少回退若干行才
開始 (例如一些只佔用若干行，但很難同步的構造)。

注意: 如果使用跨行且包含 "*/" 的字符串，C 註釋的同步方法不一定能正確工作。讓字
符串跨行是一個不好的編程習慣 (許多編譯器會給出警告)，而 "*/" 出現在註釋 (譯者
注: 應爲字符串) 的機率又相當小，一般很難注意到這個限制。


第三種同步方法:				*:syn-sync-third*

第三種同步方法只要指定 "minlines={N}" 參數。Vim 會從行號上減去 {N} 然後從那裏
開始分析。這意味着需要額外分析 {N} 行，該方法也因此較慢。例如: >
   :syntax sync minlines=50

"lines" 等價於 "minlines" (用於較老的版本)。


第四種同步方法:				*:syn-sync-fourth*

本方法試圖在若干指定區域的一端同步，稱爲同步模式。因爲只有區域可以跨行。所以如
果我們能找到某區域的一端，或許就可以知道現在在哪個語法項目之中。該方法中，搜索
從重畫開始所在的上一行開始，然後在文件中反向進行。

和非同步的語法項目類似，同步項目也可以使用 contained、matches、nextgroup 等。
但有如下區別:
- 不能使用關鍵字項目。
- 使用 "sync" 關鍵字的語法項目構成完全獨立的語法項目組。你不能混合同步組和非同
  步組。
- 匹配在緩衝區裏 (逐行) 反向進行，而不是正向。
- 可以給出續行模式，用於決定哪些行的組合可以在搜索時當成單行。這意味着搜索指定
  項目的匹配從包含續行模式的連續多行的第一行開始。
- "nextgroup" 或 "contains" 只適用於一行 (或者連續行構成的組合) 之內。
- 使用區域項目時，必須在同一行上 (或者連續行構成的組合) 開始和結束。否則，假定
  行尾 (或者連續行構成的組合的尾部) 會結束此項目。
- 如果找到同步模式的匹配，該行 (或者連續行構成的組合) 的其餘部分會搜索其它匹
  配。最後發現的匹配被使用。這可以用於同時包括區域開始和結束的行 (例如，C 註釋
  /* this */，使用最後找到的 "*/")。

有兩個使用同步模式的匹配方法:
1. 高亮分析從重畫開始處開始 (也就是同步模式的搜索起點)。必須指定在那裏出現的合
   法語法組。如果跨行的區域不會包含別的區域時，這很有效。
2. 高亮分析從匹配之後立即開始。必須指定匹配之後立即出現的合法語法組。可
   用於上述方法不適用的情形。它慢得多，因爲需要分析更多的文本。
可以同時使用兩種類型的同步模式。

除了同步模式以外，還可以指定另外的匹配和區域項目，以跳過不需要的匹配。

[之所以單獨給出同步模式，是因爲多數情況下，同步點的搜索比高亮部分的確定要簡單
得多。而模式的減少意味着速度的 (大大) 加快。]

					    *syn-sync-grouphere* *E393* *E394*
    :syntax sync match {sync-group-name} grouphere {group-name} "pattern" ..

	"這裏的組"，定義用於同步的匹配。{group-name} 爲匹配之後立刻出現的語法
	組名 (譯者注: 但不一定從那裏開始，尤其是同步模式本身就可以屬於該組)。
	文本的高亮分析在匹配之後立刻進行。{group-name} 至少應包含一個區域項
	目，並使用其中的第一個這樣的定義。"NONE" 用來指示匹配之後不存在語法
	組。

						*syn-sync-groupthere*
    :syntax sync match {sync-group-name} groupthere {group-name} "pattern" ..

	"那裏的組"，類似於 "grouphere"，但 {group-name} 是在同步點的搜索起點所
	在行的行首使用的語法組名。匹配和同步點的搜索起點之間的文本假定不會改變
	語法的高亮。例如，在 C 裏，你可以反向搜索 "/*" 和 "*/"。如果先找到
	"/*"，你知道在註釋內部，所以 "那裏的組" 是 "cComment"。如果先找到
	"*/" ，你知道不在註釋裏，所以 "那裏的組" 是 "NONE"。(實際應用中更復
	雜，因爲 "/*" 和 "*/" 可以出現在字符串中。留給讀者作爲練習吧……)。

    :syntax sync match ..
    :syntax sync region ..

	沒有 "groupthere" 參數。定義區域或匹配項目，在同步點搜索過程中跳過這些
	項目 (譯者注: 注意 同步模式只能使用匹配項目，但在這裏定義的同步過程的
	"跳過" 模式可以指定區域或匹配項目。區域項目的限制上面已有敘述)。

						*syn-sync-linecont*
    :syntax sync linecont {pattern}

	如果 {pattern} 在行內匹配，本行被認爲會在下一行繼續。這意味着同步點的
	搜索會把這些行當作連接在一起的一行處理。

如果同時給出 "maxlines={N}" 參數，尋找匹配的搜索行數限於 N 行之內。可以用於同
步項目很少且機器速度較慢的場合。例如: >
   :syntax sync maxlines=100

你可以這樣清除所有的同步設置: >
   :syntax sync clear

你也可以清除特定的同步模式: >
   :syntax sync clear {sync-group-name} ..

==============================================================================
11. 列出語法項目			*:syntax* *:sy* *:syn* *:syn-list*

本命令列出所有的語法項目: >

    :sy[ntax] [list]

要顯示單個語法組的所有語法項目: >

    :sy[ntax] list {group-name}

要列出單個簇的所有語法組:					*E392*  >

    :sy[ntax] list @{cluster-name}

":syntax" 命令的其它參數見上。

注意 ":syntax" 命令可以簡化成 ":sy"，不過 ":syn" 更常用，因爲看起來更舒服點。

==============================================================================
12. Highlight 命令			*:highlight* *:hi* *E28* *E411* *E415*

有三種類型的高亮組:
- 用於特定語言的。這些組的名字以該語言的名字開始。它們中很多沒有屬性，而是鏈接
  到第二種類型的組。
- 用於所有語法語言的。
- 用於 'highlight' 選項的。
							*hitest.vim*
用這個命令，你可以看到當前激活的所有組: >
    :so $VIMRUNTIME/syntax/hitest.vim
它會打開一個新窗口，其中包含所有的高亮組名，以它們本身的顏色顯示。

						*:colo* *:colorscheme* *E185*
:colo[rscheme]		輸出當前激活的色彩方案名。基本上等同 >
				:echo g:colors_name
<			如果 g:colors_name 沒有定義 :colo 會輸出 "default"。如
			果編譯時沒有帶 |+eval| 特性，輸出 "unknown"。

:colo[rscheme] {name}	載入色彩方案 {name}。它會在 'runtimepath' 裏搜索
			"colors/{name}.vim"，載入第一個找到的文件。
			要看到當前激活的色彩方案的名字: >
				:colo
<			該名字也保存在 g:colors_name 變量裏。
			它不能遞歸調用，所以你不能在色彩方案腳本里使用
			":colorscheme"。
			色彩方案載入後，激活 |ColorScheme| 自動命令事件。關於
			如何編寫色彩方案文件的信息: >
				:edit $VIMRUNTIME/colors/README.txt

:hi[ghlight]		列出當前所有的有屬性設置的高亮組。

:hi[ghlight] {group-name}
			列出一個高亮組。

:hi[ghlight] clear	復位高亮設置爲缺省值。刪除所有用戶增加的組的高亮屬性。
			用當前的 'background' 的值來決定所使用的缺省顏色。

:hi[ghlight] clear {group-name}
:hi[ghlight] {group-name} NONE
			屏蔽一個高亮組的所有高亮設置。並_不_復原缺省的顏色。

:hi[ghlight] [default] {group-name} {key}={arg} ..
			增加高亮組，或者更改已有的組高亮設置。
			|highlight-args| 說明 {key}={arg} 的參數。
			|:highlight-default| 說明可選的 [default] 參數。

通常，在啓動時加入高亮組。它設置高亮的缺省值。在這之後，你可以使用附加的
highlight 命令來修改你希望設置爲非缺省值的參數。也可以用 "NONE" 來撤銷某個值並
恢復缺省的值。

修改顏色的簡單方式是 |:colorscheme| 命令。它載入一個文件，裏麪包含了這樣的
":highlight" 命令: >

   :hi Comment	gui=bold
<
注意 所有沒有包含在內的設置都保持原樣，只使用指定的字段，從而和以前的設置進行
了合併。所以實際結果就像用了下面這樣的一條命令: >
   :hi Comment	term=bold ctermfg=Cyan guifg=#80a0ff gui=bold
<
							*:highlight-verbose*
如果列出高亮組時 'verbose' 非零，同時列出高亮組最近在哪裏設置。例如: >
	:verbose hi Comment
<	Comment        xxx term=bold ctermfg=4 guifg=Blue ~
	   Last set from /home/mool/vim/vim7/runtime/syntax/syncolor.vim ~

如果使用了 ":hi clear"，那麼列出缺省值的同時提到使用該命令的腳本。詳見
|:verbose-cmd|。

					*highlight-args* *E416* *E417* *E423*
用於高亮，有三種類型的終端:
term	普通的終端 (vt100、xterm)
cterm	色彩終端 (MS-DOS 控制檯、color-xterm，帶有 "Co" termcap 項目的終端)
gui	GUI

每種類型可以分別設置高亮屬性。這樣，單個語法文件就可用於所有的終端，並使用每個
終端最優的高亮設置。

1. 普通終端的高亮參數

					*bold* *underline* *undercurl*
					*inverse* *italic* *standout*
term={attr-list}			*attr-list* *highlight-term* *E418*
	attr-list 是逗號分隔的下述項目 (不能有空格) 的列表 (任何順序都可以):
		bold
		underline
		undercurl	不一定總是可用
		reverse
		inverse		等同於 reverse
		italic
		standout
		NONE		不使用屬性 (用於復位)

	注意 這裏使用 "bold" 和使用粗體字體都可以，效果相同。
	"undercurl" 是波浪狀的下劃線。如果不能用 "undercurl"，使用 "underline"
	代替。一般，只有 GUI 才能使用 "undercurl"。顏色可用 |highlight-guisp|
	設置。

start={term-list}				*highlight-start* *E422*
stop={term-list}				*term-list* *highlight-stop*
	可以得到終端上的非標準的屬性的終端代碼的列表。

	"start" 參數指定的轉義碼序列在高亮區域的字符之前被寫入，它可以是你希望
	給終端發送的用於高亮區域的任何內容。"stop" 參數指定的轉義碼序列在高亮
	區域之後被寫入，它可以撤銷 "start" 參數的效果。否則屏幕會被弄亂。

	{term-list} 可有兩種形式:

	1. 轉義序列的字符串。
	   可以是任何字符的序列，除了不能以 "t_" 開始而且不能有空格之外。這裏
	   識別 <> 記法。所以你可使用 "<Esc>" 和 "<Space>"。例如:
		start=<Esc>[27h;<Esc>[<Space>r;

	2. 終端代碼的列表。
	   終端代碼的形式是 "t_xx" ，其中 "xx" 是 termcap 項目的名字。這些代碼
	   必須以逗號分隔，而且不允許有空格。例如:
		start=t_C1,t_BL
	   要使之工作，這些終端代碼必須存在。


2. 色彩終端的高亮參數

cterm={attr-list}					*highlight-cterm*
	{attr-list} |attr-list| 的描述見上。"cterm" 參數可以和 "term" 不同，比
	如可以使用顏色。例如，在普通的終端上註釋可以用下劃線表示，在色彩終端上
	可以用藍色顯示。
	注意: 許多終端 (例如，DOS 控制檯) 不能混合使用顏色和這些屬性。這時，只
	用 "cterm=" 或者 "ctermfg=" 與 "ctermbg=" 兩者之一。

ctermfg={color-nr}				*highlight-ctermfg* *E421*
ctermbg={color-nr}				*highlight-ctermbg*
	{color-nr} 參數指定顏色號。其範圍從零到 termcap 項目 "Co" 給出的數字
	(不含)。實際的顏色取決於終端的類型和設置。有時，顏色也取決於 "cterm"
	的值。例如，有的系統上 "cterm=bold ctermfg=3" 給出另外一個顏色，別的系
	統上你只會得到顏色 3。

	xterm 上，它取決於你的資源，這並不容易預測。你的 xterm 文檔會說明缺省
	值。color-xterm 的顏色可以通過 .Xdefaults 文件修改。不幸的是，這意味着
	每個用戶未必會得到完全相同的顏色。|xterm-color| 提供帶色彩的 xterm 的
	信息。

	MSDOS 的標準顏色是固定的 (在控制窗口上)，所以我們用這些名字。在 X11
	上，顏色名字的含義是固定的，所以我們用這些顏色設置，以使高亮設置可移植
	(是不是很複雜？)。下面列出這些被識別的名字和所使用的顏色號:

							*cterm-colors*
	    NR-16   NR-8    顏色名 ~
	    0	    0	    Black (黑)
	    1	    4	    DarkBlue (深藍)
	    2	    2	    DarkGreen (深綠)
	    3	    6	    DarkCyan (深青)
	    4	    1	    DarkRed (深紅)
	    5	    5	    DarkMagenta (深品紅)
	    6	    3	    Brown，DarkYellow (褐、深黃)
	    7	    7	    LightGray、LightGrey，Gray，Grey (淺灰)
	    8	    0*	    DarkGray，DarkGrey (深灰)
	    9	    4*	    Blue，LightBlue (淺藍)
	    10	    2*	    Green，LightGreen (淺綠)
	    11	    6*	    Cyan，LightCyan (淺青)
	    12	    1*	    Red，LightRed (淺品紅)
	    13	    5*	    Magenta，LightMagenta (淺紅)
	    14	    3*	    Yellow，LightYellow (淺黃)
	    15	    7*	    White (白)

	"NR-16" 下的數字用於 16 色的終端 ('t_Co' 大於等於 16)。"NR-8" 下的數字
	用於 8 色終端 ('t_Co' 小於 16)。'*' 表明 ctermfg 使用的時候設置 bold
	屬性。在許多 8 色終端上 (比如，"linux")，它會顯示增亮的顏色。但這不適
	用於背景色。如果沒有 '*'，則不包含 bold 屬性。如果你想用不同的方式設置
	bold 屬性，在 "ctermfg=" 或 "ctermbg=" 參數_之後_設置 "cterm=" 參數。
	或者使用數字，而不是顏色名。

	忽略顏色名的大小寫。
	注意 16 色 ansi 風格的終端 (包括 xterm) 使用 NR-8 一列的數字。這裏，
	'*' 意味着 '加 8'，所以 Blue 成了 12，DarkGray 是 8，依此類推。

	注意 有些色彩終端下，這些名字可能會產生錯誤的顏色！

							*:hi-normal-cterm*
	Normal 組設置的 "ctermfg" 或 "ctermbg" 顏色成爲非高亮文本使用的顏色。
	例如: >
		:highlight Normal ctermfg=grey ctermbg=darkblue
<	設置 Normal 組的 "ctermbg" 顏色的時候，'background' 選項會自動設置。這
	使得依賴於 'background' 的高亮組發生改變！這意味着你應該先設置 Normal
	的顏色，然後再設置其它的。
	已經使用色彩方案的時候，修改 'background' 使之被重新載入，這會復位所有
	顏色 (包括 Normal)。如果你不希望如此，先刪除 "g:colors_name" 變量。

	如果你給 Normal 組設置了 "ctermfg" 或 "ctermbg"，Vim 退出時需要復位顏
	色，這通過 "op" termcap 項目 |t_op| 完成。如果不能正確工作，嘗試在你的
	.vimrc 裏設置 't_op' 選項。
							*E419* *E420*
	如果 Vim 知道 Normal 的前景和背景色，"fg" 和 "bg" 可以用做顏色名字。這
	只有在設置了 Normal 組的顏色以後和 (譯者注: 或？) 在 MS-DOS 控制臺上才
	可以。比如，設置反顯視頻: >
	    :highlight Visual ctermfg=bg ctermbg=fg
<	注意 使用的顏色必須在給出命令的時候已經合法。如果之後 Normal 組的顏色
	發生改變，"fg" 和 "bg" 顏色不會被調整。


3. GUI 的高亮參數

gui={attr-list}						*highlight-gui*
	給出 GUI 模式適用的屬性。具體描述見 |attr-list|。
	注意 這裏可以使用 "bold"，也可以使用粗體字體。效果相同。
	注意 "Normal" 組的屬性被忽略。

font={font-name}					*highlight-font*
	font-name 是字體的名字，根據 Vim 運行所在的系統而定。X11 而言，它是一
	個複雜的名字。比如: >
   font=-misc-fixed-bold-r-normal--14-130-75-75-c-70-iso8859-1
<
	字體名 "NONE" 可以用來恢復到缺省字體。如果爲 "Normal" 組設置字體，該字
	體成爲缺省字體 (直到改變了 'guifont' 選項爲止；使用最後設置的那個)。
	以下說明只適用於 Motif 和 Athena，不包括其它 GUI:
	設置 "Menu" 組的字體會改變菜單。設置 "Tooltip" 組的字體會改變工具提
	示。除了 Menu 和 Tooltip 的所有使用的字體必須和缺省字體的字符大小相
	同。否則，重畫時會有問題。

guifg={color-name}					*highlight-guifg*
guibg={color-name}					*highlight-guibg*
guisp={color-name}					*highlight-guisp*
	給出 GUI 使用的前景色 (guifg)、背景色 (guibg) 和特殊顏色 (guisp)。
	"guisp" 用於 undercurl。可用一些特殊的名字:
		NONE		沒有顏色 (透明)
		bg		使用 Normal 的背景色
		background	使用 Normal 的背景色
		fg		使用 Normal 的前景色
		foreground	使用 Normal 的前景色
	要使用有內嵌空格或者其它特殊字符的顏色名，把它放在單引號裏面。這時，不
	能使用單引號。例如: >
	    :hi comment guifg='salmon pink'
<
							*gui-colors*
	建議的顏色名 (可用於多數系統):
	    Red		LightRed	DarkRed
	    Green	LightGreen	DarkGreen	SeaGreen
	    Blue	LightBlue	DarkBlue	SlateBlue
	    Cyan	LightCyan	DarkCyan
	    Magenta	LightMagenta	DarkMagenta
	    Yellow	LightYellow	Brown		DarkYellow
	    Gray	LightGray	DarkGray
	    Black	White
	    Orange	Purple		Violet

	Win32 GUI 版本可以使用更多的系統顏色。見 |win32-colors|。

	你可以用紅、綠、藍的色值指定顏色。格式爲 "#rrggbb"，其中
		"rr"	爲紅色值
		"bb"	爲藍色值
		"gg"	爲綠色值
	所有的值都以十六進制表示，範圍是 "00" 到 "ff"。例如: >
  :highlight Comment guifg=#11f0c3 guibg=#ff00ff
<
					*highlight-groups* *highlight-default*
有一些缺省的高亮組。'highlight' 選項缺省使用這些組。注意 高亮取決於
'background' 的值。你可以用 ":highlight" 命令看到當前的設置。
							*hl-ColorColumn*
ColorColumn	用於 'colorcolumn' 設置的列
							*hl-Conceal*
Conceal		代替隱藏文本的填充字符 (見 'conceallevel')
							*hl-Cursor*
Cursor		光標所在的字符
							*hl-CursorIM*
CursorIM	類似於 Cursor，但用於 IME 模式 |CursorIM|
							*hl-CursorColumn*
CursorColumn	置位 'cursorcolumn' 時，光標所在的屏幕列
							*hl-CursorLine*
CursorLine	置位 'cursorline' 時，光標所在的屏幕行
							*hl-Directory*
Directory	目錄名 (還有列表裏的其它特殊名字)
							*hl-DiffAdd*
DiffAdd		diff 模式: 增加的行 |diff.txt|
							*hl-DiffChange*
DiffChange	diff 模式: 改變的行 |diff.txt|
							*hl-DiffDelete*
DiffDelete	diff 模式: 刪除的行 |diff.txt|
							*hl-DiffText*
DiffText	diff 模式: 改變行裏的改動文本 |diff.txt|
							*hl-ErrorMsg*
ErrorMsg	命令行上的錯誤信息
							*hl-VertSplit*
VertSplit	分離垂直分割窗口的列
							*hl-Folded*
Folded		用於關閉的摺疊的行
							*hl-FoldColumn*
FoldColumn	'foldcolumn'
							*hl-SignColumn*
SignColumn	顯示 |signs| 的列
							*hl-IncSearch*
IncSearch	'incsearch' 高亮；也用於被 ":s///c" 替換的文本
							*hl-LineNr*
LineNr		":number" 和 ":#" 命令與置位 'number' 或 'relativenumber' 選項
		時的行號。
							*hl-CursorLineNr*
CursorLineNr	和 LineNr 類似，置位 'cursorline' 或 'relativenumber' 時用於光
		標行。
							*hl-MatchParen*
MatchParen	如果光標所在或剛剛在它之前的字符是配對的括號一部分的話，它和它
		的配對。|pi_paren.txt|

							*hl-ModeMsg*
ModeMsg		'showmode' 消息 (例如，"-- INSERT --")
							*hl-MoreMsg*
MoreMsg		|more-prompt|
							*hl-NonText*
NonText		窗口尾部的 '~' 和 '@'，'showbreak' 的字符和其它在文本裏實際不
		存在的字符 (例如，代替行尾放不下的雙寬字符而顯示的 ">")。
							*hl-Normal*
Normal		普通文本
							*hl-Pmenu*
Pmenu		彈出菜單: 普通項目。
							*hl-PmenuSel*
PmenuSel	彈出菜單: 選中項目。
							*hl-PmenuSbar*
PmenuSbar	彈出菜單: 滾動條。
							*hl-PmenuThumb*
PmenuThumb	彈出菜單: 滾動條的拇指 (thumb)。
							*hl-Question*
Question	|hit-enter| 提示和 yes/no 問題
							*hl-Search*
Search		最近搜索模式的高亮 (見 'hlsearch')。也用於 quickfix 當前行的
		高亮和其它類似的要突出顯示的項目。
							*hl-SpecialKey*
SpecialKey	":map" 列出的 Meta 和特殊鍵，也包括文本里不可顯示字符的顯示和
		'listchars'。
		一般的: 和實際內容顯示上有差異的文本。
							*hl-SpellBad*
SpellBad	拼寫檢查器不能識別的單詞。|spell|
		它會和本來應該使用的高亮進行組合。
							*hl-SpellCap*
SpellCap	應該大寫字母開頭的單詞。|spell|
		它會和本來應該使用的高亮進行組合。
							*hl-SpellLocal*
SpellLocal	拼寫檢查器能識別但只在其它區域使用的單詞。|spell|
		它會和本來應該使用的高亮進行組合。
							*hl-SpellRare*
SpellRare	拼寫檢查器能識別但很少使用的單詞。|spell|
		它會和本來應該使用的高亮進行組合。
							*hl-StatusLine*
StatusLine	當前窗口的狀態行
							*hl-StatusLineNC*
StatusLineNC	非當前窗口的狀態行
		注意: 如果等於 "StatusLine"，Vim 會使用 "^^^" 指示當前窗口的狀
		態行。
							*hl-TabLine*
TabLine		標籤頁行，非活動標籤頁標籤
							*hl-TabLineFill*
TabLineFill	標籤頁行，沒有標籤的地方
							*hl-TabLineSel*
TabLineSel	標籤頁行，活動標籤頁標籤
							*hl-Title*
Title		":set all"、":autocmd" 等輸出的標題
							*hl-Visual*
Visual		可視模式的選擇區
							*hl-VisualNOS*
VisualNOS	Vim 是 "選擇區的非擁有者" 時，可視模式的選擇區。只有 X11 GUI
		的 |gui-x11| 和 |xterm-clipboard| 才提供此支持。
							*hl-WarningMsg*
WarningMsg	警告消息
							*hl-WildMenu*
WildMenu	'wildmenu' 補全的當前匹配

					*hl-User1* *hl-User1..9* *hl-User9*
'statusline' 語法允許在狀態行和標尺 (通過 'rulerformat') 上使用 9 種不同的高
亮。這些高亮組的名字是 User1 到 User9。

GUI 裏，你可以使用以下這些組來設置菜單、滾動條和工具提示的色彩。它們沒有缺省
值。這不適用於 Win32 GUI。這裏，只有三種高亮參數有效: font、guibg 和 guifg。

							*hl-Menu*
Menu		當前菜單的字體、背景色和前景色。也包括工具欄。
		可用的高亮參數: font、guibg、guifg。

		注意: Motif 和 Athena 裏，font 參數在所有情況下實際上指定字體
		集 (fontset)，不管 'guifontset' 是否爲空。所以，它和當前的
		|:language| 有關係。

							*hl-Scrollbar*
Scrollbar	主窗口滾動條的當前背景和前景色。
		可用的高亮參數: guibg、guifg。

							*hl-Tooltip*
Tooltip		當前工具提示的字體、背景色和前景色。也包括工具欄。
		可用的高亮參數: font、guibg、guifg。

		注意: Motif 和 Athena 裏，font 參數在所有情況下都指定字體集
		(fontset)，不管 'guifontset' 是否爲空，從而在設置的時候和當前
		|:language| 相聯繫。

==============================================================================
13. 鏈接組			*:hi-link* *:highlight-link* *E412* *E413*

如果如果你想爲幾個語法組使用相同的高亮設置，更簡單的方法是把這些組鏈接到一個共
同的高亮組，並且只爲該組指定顏色屬性。

要設置鏈接:

    :hi[ghlight][!] [default] link {from-group} {to-group}

要刪除鏈接:

    :hi[ghlight][!] [default] link {from-group} NONE

注意:							*E414*
- 如果 {from-group} 和/或 {to-group} 不存在，先建立之。不存在的組不會給你錯誤
  信息。
- 一旦你爲被鏈接的組使用 ":highlight" 命令，該鏈接關係就不存在了。
- 如果已經有 {from-group} 的高亮設置，鏈接不會建立，除非你給出了 '!'。如果在載
  入的文件裏執行 ":highlight link" 命令，你不會得到錯誤信息。這可以用來跳過已
  有設置的組的鏈接。

					*:hi-default* *:highlight-default*
用 [default] 參數可以設置組的缺省高亮。如果該組已經設置了高亮，或者已經存在鏈
接，忽略該命令。

這裏， [default] 對否決特定語法文件的高亮特別有用。例如，C 語法文件包含: >
	:highlight default link cComment Comment
如果你喜歡 C 註釋像 Question 一樣高亮，在你的 vimrc 文件裏放入此行: >
	:highlight link cComment Question
如果沒有 "default"，執行 C 語法文件後會覆蓋你的高亮設置。

==============================================================================
14. 清理						*:syn-clear* *E391*

如果你想爲當前緩衝區清除所有的語法設置，可以使用如下命令: >
  :syntax clear

該命令應該在你想關閉語法高亮或者切換到別的語法時使用。通常，語法文件本身不需要
它。因爲載入語法文件的自動命令會清理語法。
該命令也刪除 "b:current_syntax" 變量，因爲該命令之後沒有載入的語法了。

如果想爲所有的緩衝區關閉語法高亮，你需要刪除載入語法文件的自動命令: >
  :syntax off

該命令實際執行的是命令 >
  :source $VIMRUNTIME/syntax/nosyntax.vim
詳情見 "nosyntax.vim" 文件。注意 要使它工作，$VIMRUNTIME 必須合法。見
|$VIMRUNTIME|。

要爲當前緩衝區清理特定的語法組: >
  :syntax clear {group-name} ..
它刪除了 {group-name} 裏所有的模式和關鍵字。

要爲當前緩衝區清理特定的語法組羣 (簇): >
  :syntax clear @{grouplist-name} ..
它把 {grouplist-name} 的內容設爲空表。

						*:syntax-reset* *:syn-reset*
如果你修改了顏色並且把顏色弄亂了，使用這個命令取回缺省值: >

  :syntax reset

它不會改變 'highlight' 選項的顏色值。

注意 你在 vimrc 文件裏設定的語法顏色也會復位成其 Vim 的缺省值。
注意 如果你使用了色彩方案，色彩方案定義的語法高亮的色彩會丟失。

實際上，它做的是: >

	let g:syntax_cmd = "reset"
	runtime! syntax/syncolor.vim
<
注意 這裏使用了 'runtimepath' 選項。

							*syncolor*
如果想爲語法高亮使用不同的色彩，你可以增加一個 Vim 腳本來設置這些顏色。把該文
件放在 'runtimepath' 裏 $VIMRUNTIME 之後的一個目錄裏，以使你的設置覆蓋缺省顏色
值。這樣，這些顏色會在 ":syntax reset" 命令之後被使用。

Unix 上你可以使用文件 ~/.vim/after/syntax/syncolor.vim。例如: >

	if &background == "light"
	  highlight comment ctermfg=darkgreen guifg=darkgreen
	else
	  highlight comment ctermfg=green guifg=green
	endif
<
								*E679*
要確信這個 syncolor.vim 腳本不使用 "syntax on" 命令，設置 'background' 選項或
者使用 "colorscheme" 命令，不然會導致死循環。

注意 如果使用了色彩方案，可能會比較混淆: 到底使用的是你自己定義的顏色還是方案
裏的顏色。這取決於色彩方案文件，見 |:colorscheme|。

							*syntax_cmd*
載入 syntax/syncolor.vim 文件時，"syntax_cmd" 變量設爲以下這些值之一:
   "on"		":syntax on" 命令。高亮顏色被覆蓋，但是鏈接被保持
   "enable"	":syntax enable" 命令。只爲沒有設置過高亮的組定義顏色。使用
		":syntax default"。
   "reset"	":syntax reset" 命令或者載入色彩方案。定義所有的顏色。
   "skip"	不定義顏色。用來跳過 'runtimepath' 裏較早出現的 syncolor.vim
		已經設置過的缺省設置。

==============================================================================
15. 高亮標籤						*tag-highlight*

如果你想高亮文件裏的所有標籤，可以使用如下映射。

	<F11>	-- 生成 tags.vim 文件，並高亮標籤。
	<F12>	-- 只根據已有的 tags.vim 文件高亮標籤。
>
  :map <F11>  :sp tags<CR>:%s/^\([^	:]*:\)\=\([^	]*\).*/syntax keyword Tag \2/<CR>:wq! tags.vim<CR>/^<CR><F12>
  :map <F12>  :so tags.vim<CR>

警 告: 標籤文件越長，這會越慢，而 Vim 消耗的內存也越多。

這裏只高亮 typedef，也可以針對 union 和 struct 進行設置。爲此，你需要
Exuberant ctags (可在 http://ctags.sf.net 找到)。

在你的 Makefile 裏放入以下的行:

# 建立 types 的高亮文件。需要 Exuberant ctags 和 awk
types: types.vim
types.vim: *.[ch]
	ctags --c-kinds=gstu -o- *.[ch] |\
		awk 'BEGIN{printf("syntax keyword Type\t")}\
			{printf("%s ", $$1)}END{print ""}' > $@

在你的 .vimrc 裏放入以下的行: >

   " 載入 types.vim 高亮文件，如果存在的話
   autocmd BufRead,BufNewFile *.[ch] let fname = expand('<afile>:p:h') . '/types.vim'
   autocmd BufRead,BufNewFile *.[ch] if filereadable(fname)
   autocmd BufRead,BufNewFile *.[ch]   exe 'so ' . fname
   autocmd BufRead,BufNewFile *.[ch] endif

==============================================================================
16. 窗口局部語法				*:ownsyntax*

通常，同一個緩衝區對應的所有窗口共用相同的語法設置。不過，可以爲某個文件的某個
窗口設置單獨的語法設置。一個可能的例子，在一個窗口中使用普通的高亮方式編輯
LaTeX 源代碼，另一個窗口用不同的高亮方式訪問相同的代碼 (例如隱藏控制序列，實際
對文本加粗，加斜體等等)。'scrollbind' 選項可用於此。

要使當前窗口使用語法 "foo"，而不影響緩衝區的其它窗口: >
   :ownsyntax foo
<						*w:current_syntax*
這樣做，"w:current_syntax" 變量會設爲 "foo"。"b:current_syntax" 的值不變。實際
上，這是通過保存和恢復 "b:current_syntax" 來實現的，因爲語法文件會設置
"b:current_syntax"。但語法文件設置的值會被轉賦到 "w:current_syntax" 上。

一旦窗口有自己的語法，同一緩衝區其它窗口執行的語法命令 (包括 :syntax clear) 就
不會有效果。相反地，此窗口執行的語法命令對同一緩衝區其它窗口也沒有效果。

帶有自己語法的窗口當載入其它緩衝區或重載文件時，會恢復到正常行爲。
分割窗口時，新窗口使用原有的語法。

==============================================================================
17. 彩色 xterm					*xterm-color* *color-xterm*

多數彩色 xterm 只有八色。如果你得不到缺省設置的顏色，在 .vimrc 裏使用這些行應
該就可以了: >
   :if &term =~ "xterm"
   :  if has("terminfo")
   :	set t_Co=8
   :	set t_Sf=<Esc>[3%p1%dm
   :	set t_Sb=<Esc>[4%p1%dm
   :  else
   :	set t_Co=8
   :	set t_Sf=<Esc>[3%dm
   :	set t_Sb=<Esc>[4%dm
   :  endif
   :endif
<	[<Esc> 是真正的 escape，輸入 CTRL-V <Esc>]

你可能需要修改第一個 "if" 來匹配你的終端的名字。比如，"dtterm" 取代 "xterm"。

注意: 在 ":syntax on" 執行_之前_這些設置。否則顏色可能不正確。
							*xiterm* *rxvt*

上面提到的設置也適用於 xiterm 和 rxvt。但要在 rxvt 裏使用 16 色，可以使用
terminfo 並執行如下命令: >
	:set t_AB=<Esc>[%?%p1%{8}%<%t25;%p1%{40}%+%e5;%p1%{32}%+%;%dm
	:set t_AF=<Esc>[%?%p1%{8}%<%t22;%p1%{30}%+%e1;%p1%{22}%+%;%dm
<
							*colortest.vim*
要測試你的色彩設置，Vim 發佈版本里包含了一個文件。要使用它，執行如下命令: >
   :runtime syntax/colortest.vim

即使顏色數定義爲 8，一些版本的 xterm (還有其他終端，比如 linux 控制檯) 可以輸
出更亮的前景色。因此如果 't_Co' 爲 8，Vim 爲淺色的前景色設置 "cterm=bold" 屬
性。

							*xfree-xterm*
要得到 16 色或更多，需要最新的 xterm 版本 (應該包含在 Xfree86 3.3 或更新的版本
裏)。你可以在這裏得到最新的版本: >
	http://invisible-island.net/xterm/xterm.html
下面是 configure 的好方法。它使用 88 色，並打開 termcap-query 特性。這使得 Vim
能夠詢問 xterm 可以支持多少顏色。 >
	./configure --disable-bold-color --enable-88-color --enable-tcap-query
如果你只有 8 色，檢查 xterm 的編譯設置。
(另見 |UTF8-xterm|，瞭解如何在該 xterm 裏使用 UTF-8 字符編碼)。

在你的 .vimrc 放入以下幾行，該 xterm 應該工作 (16 色): >
   :if has("terminfo")
   :  set t_Co=16
   :  set t_AB=<Esc>[%?%p1%{8}%<%t%p1%{40}%+%e%p1%{92}%+%;%dm
   :  set t_AF=<Esc>[%?%p1%{8}%<%t%p1%{30}%+%e%p1%{82}%+%;%dm
   :else
   :  set t_Co=16
   :  set t_Sf=<Esc>[3%dm
   :  set t_Sb=<Esc>[4%dm
   :endif
<	[<Esc> 是真正的 escape，輸入 CTRL-V <Esc>]

沒有 |+terminfo| 的話，Vim 會識別這些設置，並自動把 cterm 的第 8 色或更高的顏
色翻譯成 "<Esc>[9%dm" 和 "<Esc>[10%dm"。第 16 色以上也自動進行翻譯。

有報告說這樣可以用於 256 色: >

   :set t_AB=<Esc>[48;5;%dm
   :set t_AF=<Esc>[38;5;%dm

或者只設置 TERM 環境變量爲 "xterm-color" 或 "xterm-16color"，然後試試行不行。

你也許想使用如下 X 資源 (在你的 ~/.Xdefaults 文件裏):
	XTerm*color0:			#000000
	XTerm*color1:			#c00000
	XTerm*color2:			#008000
	XTerm*color3:			#808000
	XTerm*color4:			#0000c0
	XTerm*color5:			#c000c0
	XTerm*color6:			#008080
	XTerm*color7:			#c0c0c0
	XTerm*color8:			#808080
	XTerm*color9:			#ff6060
	XTerm*color10:			#00ff00
	XTerm*color11:			#ffff00
	XTerm*color12:			#8080ff
	XTerm*color13:			#ff40ff
	XTerm*color14:			#00ffff
	XTerm*color15:			#ffffff
	Xterm*cursorColor:		Black

[注意: 需要 cursorColor 來繞過一個漏洞。該漏洞把光標顏色設爲最後顯示的文本的顏
色。在較新的版本里該問題被修正，但還不是所有人都使用新版本。]

要立刻使用，在 X 選項數據庫管理器裏重新載入 .Xdefaults 文件 (你只須在改變
.Xdefaults 文件的時候這麼做就可以了): >
  xrdb -merge ~/.Xdefaults
<
					*xterm-blink* *xterm-blinking-cursor*
要使光標在 xterm 上閃爍，見 tools/blink.c。或者使用 Thomas Dickey 的 xterm 補
丁號 107 以上的版本 (取得的方法見上)，使用這些資源:
	XTerm*cursorBlink:	on
	XTerm*cursorOnTime:	400
	XTerm*cursorOffTime:	250
	XTerm*cursorColor:	White

							*hpterm-color*
下面的設置 (或多或少) 在 hpterm 裏工作，它只支持 8 種前景色: >
   :if has("terminfo")
   :  set t_Co=8
   :  set t_Sf=<Esc>[&v%p1%dS
   :  set t_Sb=<Esc>[&v7S
   :else
   :  set t_Co=8
   :  set t_Sf=<Esc>[&v%dS
   :  set t_Sb=<Esc>[&v7S
   :endif
<	[<Esc> 是真正的 escape，輸入 CTRL-V <Esc>]

						*Eterm* *enlightened-terminal*
有報告稱下面的設置可以使得 Enlightened terminal emulator，或 Eterm，工作。它們
可能適用於所有的和 xterm 類似並使用 bold 屬性來取得亮色的終端。有必要的話，增
加類似於上面那樣的 ":if"。 >
       :set t_Co=16
       :set t_AF=^[[%?%p1%{8}%<%t3%p1%d%e%p1%{22}%+%d;1%;m
       :set t_AB=^[[%?%p1%{8}%<%t4%p1%d%e%p1%{32}%+%d;1%;m
<
						*TTpro-telnet*
下面的設置應該適用於 TTpro telnet。Tera Term Pro 是 MS-Windows 上一個自由軟件
/ 開源程序。 >
	set t_Co=16
	set t_AB=^[[%?%p1%{8}%<%t%p1%{40}%+%e%p1%{32}%+5;%;%dm
	set t_AF=^[[%?%p1%{8}%<%t%p1%{30}%+%e%p1%{22}%+1;%;%dm
要確信打開了 TTpro 的 Setup / Window / Full Color，並確信_沒有_打開 Setup /
Font / Enable Bold。
(由 John Love-Jensen <eljay@Adobe.COM> 提供信息)


==============================================================================
18. 語 法 太 慢 了						*:syntime*

本節主要針對語法文件的作者。

如果語法導致重畫變慢，有一些小竅門。打開一些通常會有干擾的特性，比如
'relativenumber' 和 |folding|，會看到是否變慢。

注意: 僅當編譯時帶 |+profile| 特性纔可用。可能需要編譯 Vim 時帶 "huge" 特性
包。

要知道哪些模式花了最多時間，下面的命令序列會給出概要: >
	:syntime on
	[ 至少用 CTRL-L 重畫文本一次 ]
	:syntime report

此時會顯示使用到的語法模式的列表，按匹配文本使用的時間排序。

:syntime on		開始測量語法時間。會增加若干開銷，用來計算語法模式匹配
			的時間。

:syntime off		停止測量語法時間。

:syntime clear		把所有的計數清零，重新開始測量。

:syntime report		在當前窗口顯示 ":syntime on" 開始使用的語法項目。使用
			更寬的顯示可以看到更多輸出。

			列表按總時間排序。顯示以下諸列:
			TOTAL		用於匹配本模式的總時間，按秒計。
			COUNT		本模式使用的次數。
			MATCH		本模式實際匹配的次數。
			SLOWEST		單次匹配最長的時間。
			AVERAGE		單次匹配平均時間。
			NAME		語法項目名。注意 這未必唯一。
			PATTERN		使用的模式。

模式的匹配如果要嘗試不同的分支時會變慢。儘量包括更多的直義文本，以減少模式_不_
匹配的可能性。

如果用 "\@<=" 和 "\@<!" 項目，加入最大範圍來避免匹配本行和前行的所有可能位置。
例如，如要項目是直義文本，指明文本的長度 (以字節計):

"<\@<=span"	匹配 "<span" 中的 "span"。會試圖在很多位置匹配 "<"。
"<\@1<=span"	相同匹配，但僅嘗試 "span" 之前的一個字節。


 vim:tw=78:sw=4:ts=8:ft=help:norl:
