*usr_28.txt*	For Vim version 7.4.	最近更新: 2013年8月

		     VIM 用戶手冊 - Bram Moolenaar 著
		  譯者:  Chimin Yen http://vimcdoc.sf.net

				   摺疊


結構化的文本可以分爲許多節。而一節之內可以再分小節。摺疊允許你將一節顯示爲一
行，並提供文本的概覽。本章將解釋各種實現摺疊的方法。

|28.1|	什麼是摺疊？
|28.2|	手動摺疊
|28.3|	對摺疊的操作
|28.4|	存儲和恢復摺疊
|28.5|	依縮進摺疊
|28.6|	依標誌摺疊
|28.7|	依語法摺疊
|28.8|	依表達式摺疊
|28.9|	摺疊未被改動的行
|28.10|	使用哪種摺疊辦法呢？

       下一章: |usr_29.txt|  在代碼間移動
       前一章: |usr_27.txt|  查找命令及模式
         目錄: |usr_toc.txt|

==============================================================================
*28.1*	什麼是摺疊？

摺疊用於把緩衝區內某一範圍內的文本行顯示爲屏幕上的一行。就像一張紙，要它縮短
些，可以把它摺疊起來:

	+------------------------+
	| 行 1		 |
	| 行 2		 |
	| 行 3		 |
	|_______________________ |
	\			 \
	 \________________________\
	 / 被摺疊的行		  /
	/________________________/
	| 行 12		 |
	| 行 13		 |
	| 行 14		 |
	+------------------------+

那些文本仍然在緩衝區內而沒有改變。受到摺疊影響的只是文本行顯示的方式。

摺疊的好處是，通過把多行的一節摺疊成帶有摺疊提示的一行，會使你更好地瞭解對文本
的宏觀結構。

==============================================================================
*28.2*	手動摺疊

試一試: 把光標置於某一段落內，並鍵入: >

	zfap

你將會看到該段落被一行高亮的文本所代替。你已經創建了一個折疊了。|zf| 是個操作
符，而 |ap| 是一個文本對象。你可以將 |zf| 操作符跟任何一個移動命令聯用，爲所經
之處的文本創建一個摺疊。 |zf| 也能在可視模式下使用。

若要再閱讀那些文本，可以鍵入以下命令以打開該摺疊: >

	zo

你還可以用以下命令再關閉該摺疊: >

	zc

所有的摺疊命令都以 'z' 開頭。展開你的想像力，這個字母看起來就像一張摺疊起來的
紙的側面。而 "z" 後面可用的字母，由於採用了幫助記憶方法選擇，很容易記得住:

	zf	F-old creation (創建摺疊)
	zo	O-pen a fold (打開摺疊)
	zc	C-lose a fold (關閉摺疊)

摺疊可以嵌套: 一個含有摺疊的文本區可以被再次摺疊。例如，你可以摺疊本節內每一段
落，然後摺疊本章內所有的節。試試看。你將注意到，打開全章的摺疊，會將節的摺疊還
原得跟以前一樣，有些打開，而有些關閉。

假定你已經創建了若干摺疊，而現在需要閱覽全部文本。你可以移到每個摺疊處，並鍵入
"zo"。若要做得更快，可以用這個命令: >

	zr

這將減少 (R-educe) 摺疊。相反的操作是: >

	zm

這將摺疊更多 (M-ore)。你可以重複 "zr" 和 "zm" 來打開和關閉若干層嵌套的摺疊。

如果你有一個嵌套了好幾層深的摺疊，你可以用這個命令把它們全部打開: >

	zR

這將減少摺疊直至一個也不剩。而用下面這個命令你可以關閉所有的摺疊: >

	zM

這將增加摺疊，直至所有的摺疊都關閉了。

你可以用 |zn| 命令快速禁止摺疊功能。然後 |zN| 恢復原來的摺疊。|zi| 切換於兩者
之間。以下步驟是一種實用的操作方法:
- 創建摺疊，以獲取你的文件的概覽
- 移動到你要操作的地方
- 執行 |zi| 以便一邊看着文本，一邊編輯
- 再執行 |zi|  以便移動到另一處

在參考手冊中有更多關於手動摺疊的內容: |fold-manual|

==============================================================================
*28.3*	對摺疊的操作

當一些摺疊關閉時，移動命令，如 "j" 和 "k" 會輕鬆的移過摺疊，就像它是單個空行一
樣。這允許你快速移過折疊了的文本。

你可以向對待單行一樣複製，刪除和粘貼摺疊。當你要改動某個程序裏的函數的先後次序
時，這是很實用的。首先，爲 'foldmethod' 選擇一個正確的摺疊方法，以保證每個摺疊
包含了整個函數 (或稍缺一點兒)。然後，用 "dd" 命令刪除該函數，移動光標，並用
"p" 命令粘貼。如果函數中某些行在摺疊之上，或之下，你可以利用可視模式下的選擇方
法:
- 把光標置於被移文本的首行
- 擊 "V" 鍵開始可視模式
- 把光標置於被移文本的末行
- 擊 "d" 鍵刪除被選中的行。
- 把光標移到新位置，並擊 "p" 鍵把文本粘貼在那兒。

有時候，查看或記住一個摺疊在哪兒，挺不容易的。更別說用 |zo| 命令來打開了。要查
看那些已定義的摺疊: >

	:set foldcolumn=4

這個命令將在窗口左邊顯示一小欄來標識各個摺疊。一個 "+" 表示某個關閉的摺疊。一
個 "-" 表示每個打開的摺疊的開頭，而 "|" 則表示該摺疊內其餘的行。

你可以在摺疊欄內用鼠標點擊 "+"，以打開一個摺疊。點擊 "-" ，或在它之下的某個
"|" ，將關閉一個打開的摺疊。

打開所有光標行上的摺疊用 |zO|。
關閉所有光標行上的摺疊用 |zC|。
刪除一個光標行上的摺疊用 |zd|。
刪除所有光標行上的摺疊用 |zD|。

當你進入插入模式後，光標行上的摺疊永遠不會關閉。那是要讓你看見你打的什麼字！

當光標前後跳轉至摺疊，或在摺疊上左右移動時，摺疊就會自動打開。例如，零命令 "0"
打開光標下的摺疊 (假設 'foldopen' 包含 "hor"，即默認設置)。'foldopen' 選項可以
修改，爲指定的某一類命令打開摺疊。如果你要光標遇到摺疊，摺疊就打開，那麼可以這
麼做: >

	:set foldopen=all

警告: 你將因此無法移到一個關閉的摺疊上。你也許只想臨時用一用這個命令，然後把它
設回默認值: >

	:set foldopen&

你可以在移開摺疊時自動關閉摺疊: >

	:set foldclose=all

這個命令將重新把摺疊級別 'foldlevel' 作用到所有的不含光標的摺疊。你必須自己試
試看你會不會喜歡這個設置。用 |zm| 增加摺疊級別，並用 |zr| 減少摺疊級別 (減少折
疊的層次)。

摺疊是限於本地窗口的。這允許你爲同一緩衝區打開兩個窗口，一個帶摺疊，而另一個不
帶摺疊。或者，一個讓所有的摺疊關閉，而另一個則讓所有的摺疊打開。

==============================================================================
*28.4*	存儲和恢復摺疊

當你放棄一個文件時 (開始編輯另一個)，其摺疊狀態就丟失了。如果你稍後再回來編輯
同一文件，那麼，所有手動打開和關閉的摺疊，全都恢復到它們的默認狀態了。如果摺疊
是用手動方式創建的，則所有的摺疊都消失了！爲了保存摺疊，可以用 |:mkview| 命
令: >

	:mkview

這將儲存那些影響文件視圖的設定及其它內容。你可以利用 'viewoptions' 選項修改儲
存的範圍。當你稍後回到同一文件時，你可以重新載入這個視圖: >

	:loadview

你可以爲一個文件儲存多至十個視圖。例如，把當前設置儲存爲第三個視圖，並載入第
二個視圖: >

	:mkview 3
	:loadview 2
<
注意 當你插入或刪除一些文本行時，視圖可能變得無效。還得檢查 'viewdir' 選項，它
指定視圖文件儲存在哪兒。你可能時不時需要刪除舊的視圖文件。

==============================================================================
*28.5*	依縮進摺疊

使用 |zf| 來定義一個摺疊很費事。如果你的文本依循一種結構，以較多的縮進表示較低
的層次，那麼，你可以採用縮進摺疊的方法。這將爲每一系列有相同縮進的行創建一個折
疊。縮進較多的行將成爲嵌套的摺疊。縮進摺疊適用於許多編程語言。

我們來試試這個方法。先設定 'foldmethod' 選項: >

	:set foldmethod=indent

然後你可以用 |zm| 和 |zr| 命令增加和減少摺疊。在下面這個例文上很容易看明白:

本行沒有縮進
	本行被縮進一次
		本行被縮進兩次
		本行被縮進兩次
	本行被縮進一次
本行沒有縮進
	本行被縮進一次
	本行被縮進一次

注意 縮進多少和摺疊深度之間的關係倚賴於 'shiftwidth' 選項。每個 'shiftwidth'
選項規定的縮進寬度，在摺疊深度上加一。這被稱爲一個摺疊級別。

當你使用 |zr| 和 |zm| 命令時，你實際上是在增加或減少 'foldlevel' 選項。你也可
以直接設置它: >

	:set foldlevel=3

這意味着，所有縮進等於或大於 'shiftwidth' 三倍的摺疊將被關閉。摺疊級別設定得越
低，越多的摺疊將被關閉。當 'foldlevel' 爲零時，所有的摺疊都將被關閉。|zM| 把
'foldlevel' 設爲零。相反的命令 |zR| 把 'foldlevel' 設爲文件中最深的摺疊級別。

因此，有兩種方法開啓和關閉摺疊:
(A) 設定摺疊級別。
    這提供了一種極快的 "縮小" 方法來查看文本結構，移動光標，以及重新 "放大" 到
    具體的文本。

(B) 利用 |zo| 和 |zc| 命令打開和關閉指定的摺疊。
    這個方法允許你僅僅打開那些你要打開的摺疊，而不影響其它的摺疊。

這兩種方法可以結合起來用: 你可以先用幾次 |zm| 以關閉大多數摺疊，然後用 |zo|
打開一個指定的摺疊。或者，用 |zR| 打開所有的摺疊，然後用 |zc| 關閉指定的摺疊。

但是，當摺疊方法 'foldmethod' 的值爲 "indent" 時，你不能手動定義摺疊。因爲那樣
會引起縮進寬度和摺疊級別之間的衝突。

在參考手冊中有更多關於縮進摺疊的內容: |fold-indent|

==============================================================================
*28.6*	依標誌摺疊

文本中的標誌用於指定一個摺疊區的起點和終點。標誌摺疊可以精確地控制一個摺疊究竟
包含哪些行文本。缺點是文本需要改動。

試試這個: >

	:set foldmethod=marker

以下列 C 程序片段爲例:

	/* foobar () {{{ */
	int foobar()
	{
		/* return a value {{{ */
		return 42;
		/* }}} */
	}
	/* }}} */

請注意，摺疊行將顯示位於標誌之前的文字。這正好用來說明該摺疊包含了什麼。

令人十分困擾的是，當某些文本行移動後，標誌不再正確地配對。這種局面可以利用編號
標誌來避免。例如:

	/* global variables {{{1 */
	int varA，varB;

	/* functions {{{1 */
	/* funcA() {{{2 */
	void funcA() {}

	/* funcB() {{{2 */
	void funcB() {}
	/* }}}1 */

每一個編號標誌表示一個編號指定級別的摺疊的開始。這將使任何較高層次的摺疊在此結
束。你可以只用編號標誌的開始符定義所有的摺疊。只有當你要明確地在另一個開始前結
束一個摺疊時，你才需要加一個標誌停止符。

在參考手冊中有更多關於標誌摺疊的內容: |fold-marker|

==============================================================================
*28.7*	依語法摺疊

Vim 爲每一種不同的語言使用一個不同的語法文件。語法文件爲文件中各種不同語法項定
義顏色。如果你正用 Vim 在一個支持色彩的終端上閱讀本文，你所看見的色彩就是由語
法文件 "help" 定製的。
   在語法文件中，你可以加入一些帶有 "fold" 參數的語法項。這些語法項將定義摺疊
區。這要求寫一個語法文件，把這些項目加入其中。編寫這樣一個文件是不容易的。但是
一旦寫成，所有摺疊的創建就變成自動的了。
   在此，我們將假定你正使用一個已經寫好的語法文件。這樣的話，就沒更多解釋的必
要了。你可以像以上解釋過的那樣打開和關閉摺疊。編輯文件時摺疊會自動創建和刪除。

在參考手冊中有更多關於語法摺疊的內容: |fold-syntax|

==============================================================================
*28.8*	依表達式摺疊

表達式摺疊類似於縮進摺疊，但並非利用文本行的縮進，而是調用一個函數來計算一行的
摺疊級別。當文本的一部分表明那些行屬於同一組時，你可以使用這個方法。一個例子是
電子郵件，其中引述的文本由行首的 ">" 來表示。要摺疊這些引文，可以用以下命令: >

	:set foldmethod=expr
	:set foldexpr=strlen(substitute(substitute(getline(v:lnum),'\\s','',\"g\"),'[^>].*','',''))

你可以在這段文本上試式看:

> quoted text he wrote
> quoted text he wrote
> > double quoted text I wrote
> > double quoted text I wrote

以下是上例中 'foldexpr' 的解釋 (自裏至外):
   getline(v:lnum)			讀取當前行
   substitute(...,'\\s','','g')		從當前行刪除所有空白字符
   substitute(...,'[^>].*','','')	刪除行首那些 '>' 之後的任何字符
   strlen(...)				計算字符串的長度，即 '>' 的個數

注意 在 ":set" 命令中，每一個空格，雙引號和反斜線符之前，必須插入一個反斜槓。
如果這會把你搞糊塗，那麼就執行  >

	:set foldexpr

來檢查所產生的實際值。爲了修正一個複雜的表達式，請使用命令行補全: >

	:set foldexpr=<Tab>

其中 <Tab> 是一個真實的 Tab 鍵。Vim 將填入以前的值，然後你可以編輯它。

當該表達式變得相對複雜時，你應當將其放入一個函數。然後設定 'foldexpr' 來調用該
函數。

在參考手冊中有更多關於表達式摺疊的內容: |fold-expr|

==============================================================================
*28.9*	摺疊未被改動的行

當你在同一窗口也設定 'diff' 選項時，這種摺疊方法就很有用。|vimdiff| 命令爲你設
定好了使用未改行摺疊。例如: >

	:setlocal diff foldmethod=diff scrollbind nowrap foldlevel=1

在顯示同一文件的不同版本的每個窗口內執行這個命令。你將清楚地看到不同文件間的區
別，因爲那些沒改動的文本都被摺疊起來了。

更多細節參見 |fold-diff|。

==============================================================================
*28.10* 使用哪種摺疊辦法呢？

所有這些可能性讓你感到納悶，你究竟應該選擇哪種方法。不幸的是，沒有放之四海皆準
的法則。這裏只給出一些提示。

如果存在一個語法文件，其中定義的摺疊符合你正在使用的程序語言，那麼，語法摺疊應
該是最好的選擇。否則，你也許得試着寫一個。這要求你相當的瞭解關於查找模式知識。
這並非易事。但一旦寫成，你將不必以手動的方式定義折疊了。

鍵入命令，手動摺疊一個個文本區的方法可用於無結構特點的文本。然後用 |:mkview|
命令來儲存和還原摺疊狀態。

標誌摺疊法要求你修改文件。如果你與它人共享這個文件，或不得不遵守公司規定的標
準，那麼你也許得不到許可給文件加標誌。
   標誌摺疊的主要優點是，你可以精確的把標誌放在你要的位置。那樣就避免了那種在
你剪切和粘貼摺疊時漏了幾行文本的情況。並且，你還可以加個註釋，說明該摺疊包含些
什麼。

縮進摺疊法是那種在許多文件裏都用的着。但並不是每次都能成功的方法。當你無法採用
其它方法時，就用這種。然而，縮進摺疊在做提綱時特別有用。你必須爲每一層嵌套摺疊
特意的使用同一縮進寬度 'shiftwidth'。

表達式摺疊法能夠在幾乎任何有結構特定的文本中創建摺疊。這種方法相當簡單，尤其當
摺疊的開始和結束處能容易地被識別的時候。
   如果你用 "expr" 方法來定義摺疊而無法得到完全滿意的結果。那麼你可以切換到手
動方法 "manual"。這麼做不會刪除那些已經定義好了的摺疊。之後你便可以手動刪除或
增加折疊了。

==============================================================================

下一章: |usr_29.txt|  在代碼間移動

版權: 參見 |manual-copyright|  vim:tw=78:ts=8:ft=help:norl:
